<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng"
        schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml"
        schematypens="http://purl.oclc.org/dsdl/schematron"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>Integration Testing</title>
    <date>4Q18</date>
    <keywordset>
      <keyword>application-development</keyword>
      <keyword>testing</keyword>
    </keywordset>
  </info>
  <!-- ================================================================== -->
  <para>This article discusses intergration testing of eXist-db applications. It also covers recommendations for the configuration of automated test environments, and explains the
    minimum testing requirements for apps that are published under the eXist-db namespace.</para>
  <para>It assumes that you are familiar with the <link xlink:href="xqsuite">XQsuite framework</link> for unit-testing, and the general strategies for designing <link xlink:href="testing">tests</link> in eXist-db.</para>
  <!-- ================================================================== -->
  <sect1 xml:id="int-test">
    <title>Introduction</title>
    <para>Creating an automated mininal testsuite is possible with relatively little effort. It pays to take the need for testing into account when you start developing your
      application. This enables others to extend your program with new features, by knowning that these don't break existing functions. It also allows test only contributions, to
      help you to gradually advance your test coverage. The following section will walk you trough the three main aspects of such a minimal test setup.</para>
    <sect2 xml:id="ci-build">
      <title>Building on a clean system</title>
      <para>Before you start designing tests, you should start to automate your build process. This ensures that things don't only work on your system, and it can catch some common
        errors.</para>
      <para>The examples in this article will use <link condition="_blank" xlink:href="https://travis-ci.com">travis-ci</link> as it is the most popular continual integration (ci)
        provider in the exist-db organization on Github, other popuar choices include <link condition="_blank" xlink:href="https://www.appveyor.com">appveyor</link>, <link condition="_blank" xlink:href="https://jenkins.io">jenkins</link>, <link condition="_blank" xlink:href="https://circleci.com">circl-ci</link>, … .</para>
      <para>The services typically require a small configuration file, so you can build your code on a clean virtual machine, without the risk of local files interfering. For
        travis the required name of such a file is <literal>.travis.yml</literal> and in its simplest form it would look like this:</para>
      <programlisting language="yaml" xlink:href="listings/travis-1.txt"/>
      <para>For the correct way to create such a configuration file for other CI providers please consult their documantation. In all cases, since exist-db is written in Java, your
        app should be build on a system that comes with the minimal Java version required by eXist-db.</para>
      <note>
        <para>Most providers will automatically detect your build tool and run the required command even if you don't specify it. In the above example, our app to be tested uses
          ant as a build tool, change <code>ant</code> to suite your needs, e.g. <code>maven clean package</code>, <code>npm install</code>, etc.</para>
      </note>
      <para>If you have multiple build targets for production and development, you should make sure that each build targets is actually run by the ci service.</para>
      <para>You can extend this basic template according to your needs, e.g.: Apps written in java might want to run the build step on multiple java versions (by adding <code>-
          openjdk11</code>); or to test building on on different operation systems. You should consult your ci services documentation for the list of available configuration
        options.</para>
    </sect2>
    <sect2 xml:id="ci-install">
      <title>Add a running eXist-db instance and install your app</title>
      <para>The next step is to take the result of your automated build process and install it in a running eXist-db instance. We are going to use exist's <link condition="_blank" xlink:href="https://github.com/eXist-db/docker-existdb">docker images</link> for this, since it is supported by all CI providers, and it tends to be the fastest means of
        getting an instance up and running. Let's extend the file create in the previous section.</para>
      <programlisting language="yaml" xlink:href="listings/travis-2.txt"/>
      <para>The <literal>:release</literal> and <literal>:latest</literal> tags are specifically designed for use in ci environments. You can also specify exact version to use
        (e.g. <literal>:4.4.0</literal>), if you want to ensure backwards compatibility. But these two tags will ensure that your code is tested against both the most current
        stable release, and upcoming changes.</para>
      <note>
        <para> To actually install the app we have simply copied it into exist's <literal>autodeploy</literal> folder, which will make sure that any dependencies that you declared
          for your app, will also be installed. If you require more complex installation steps, you can find more examples and links in the <link condition="_blank" xlink:href="https://github.com/eXist-db/docker-existdb">docker-existdb readme</link>.</para>
      </note>
      <para> So far we have simply automated the basic steps of building and installing your app. This already catches some basic and particularly severe erros, but it is not a
        very realistic test of what users actually experience when they install your application. Before we can refine the way we imitate their process properly, we first need to
        add the means of running actual tests within our ci environment.</para>
    </sect2>
    <sect2 xml:id="ci-unit">
      <title>Integrating unit tests into ci</title>
      <para>Integration testing and unit testing go hand in hand, as one without the other does not work well. If you are writing an application, you already should have unit tests
        for the functional components of your code. By running your unit tests inside your ci server, these become immediately visible to potential contributors, and you have the
        advantage of immediate feedback on every code change.</para>
      <important>
        <para>Tests that are invisible to other contributers because they are hidden away, and have only every been run on the original authors system, are of very limited
          use.</para>
      </important>
      <para>As with the previous options there are different test runners to do this work for you, such as <link condition="_blank" xlink:href="https://junit.org/junit5/">junit</link> for java, <link condition="_blank" xlink:href="https://mochajs.org">mocha</link> for javascript, <link condition="_blank" xlink:href="xqsuite">xQsuite</link> for xQuery. To run your tests, we are going to leverage the support for running unit tests of our build system (e.g.: <code>npm test</code>, <code>mvm test</code>,
        …):</para>
      <programlisting language="yaml" xlink:href="listings/travis-3.txt"/>
      <note>
        <para>Just as with the building example, many providers will execute this command automatically. But even in a simple case it helps others understand your code, and to find
          your tests, if you make the test command explicit.</para>
      </note>
      <para>If you use more then one test runner, you can simply add additional test commands to the script parameter. Since exist is already running in the background t our app
        installed, it is also possible to run your <literal>xqsuite</literal> unit tests. You can see how this is configured, for apps using our the <link condition="_blank" xlink:href="https://github.com/eXist-db/generator-exist">yeoman templates</link>.</para>
      <para>How to write good unit tests is beyond the scope of this article. Whenever you are struggling with your integration test, you should however, ask yourself if what you
        are trying to achieve, might not be better served by creating unit tests. Whichever solution works best for you, you should not rely on integration tests alone, and your
        unit tests should be integrated into your ci system.</para>
    </sect2>
    <sect2 xml:id="ci-integration">
      <title>Testing your app in a controlled context</title>
      <para>As we have seen in the previous section unit tests are an important pre-requiste for effective integration testing. The difference between the two is that unit tests
        excell at testing individual functions, and are quick to write and perform. Yet, they cannot capture the complex interaction between your code and that of the larger
        environment. Just search for <link condition="_blank" xlink:href="https://www.google.com/search?hl=en&amp;q=2%20unit%20tests%200%20integration%20tests">2 unit tests 0
          integration tests</link> to see what I mean.</para>
      <para>For eXist-db applications, integration test will typically involve a browser, as we are trying to mimick the way a user interacts with our application from their system.</para>
      <note><para>
        While our examples focus on browser testing, you can see shell based integration tests at the <link condition="_blank" xlink:href="https://github.com/eXist-db/docker-existdb/blob/develop/.travis.yml">test-suite</link> for building the docker images we used earlier.</para></note>
      <para>Common tools for browser testing include <link condition="_blank" xlink:href="https://www.cypress.io">cypress</link>, <link condition="_blank" xlink:href="https://docs.seleniumhq.org">Selenium</link>, and <link condition="_blank" xlink:href="http://webdriver.io">webdriver</link>. As before the choice is up to
        you, whichever you choose it should be clearely documented so your contributors know how to adjust test cases for new features and how to maintain your tests. We focus on
        cypress, as it does not require any additional steps for configuring a browser first.</para>
      <note>
        <para>If you need to perform cross-browser testing you can take a look at services such as <link condition="_blank" xlink:href="https://saucelabs.com">sauce
          labs</link></para>
      </note>
      <para>You can simply execute the cypress test command inside your ci test script after the unit test command we added earlier.</para>
      <programlisting language="yaml" xlink:href="listings/travis-4.txt"/>
      <para>With cypress you write your tests in the same fashion as you would with mocha unit tests, however, you now address the rendered document inside a browser instead of
        individual js functions.</para>
      <programlisting language="json" xlink:href="listings/cypress.txt"/>
      <para>The above example opens a page (the dashboard) in the browser, logs in, and close the window it just opened. You can do many more things, but these kind of simple
        examples should give you a good starting point for creating your first integration test. If there are any console errors or problems with rendering content cypress will
        create an error message and your tests will fail. To check the syntax of these commands, and to see many more examples please visit the <link condition="_blank" xlink:href="https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests.html#Folder-Structure">cypress documentation</link>.</para>
      <para>Now that we have build our app on a clean system, executed its unit tests, and opened the start page of our freshly installed app in clean eXist-db instance, we have
        achieved a basic smoke test. We switched it on and there was no smoke. Proper testing can now commence. Obviously you might want to visit multiple pages, or compare
        screenshots to avoid visual regressions, or compare images in multiple browsers, or … .</para>
      <para>All of which are excellent ideas, and with these basics in place it might no longer seem so daunting a task. Depending on your own specific requirments I would
        encourage your to browse other eXist-db repositories in addition to the documentation of your CI and test-suite vendors. Chances are someone already has created a solid
        test, similar to what you want to try.</para>
    </sect2>
  </sect1>
</article>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng"
        schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml"
        schematypens="http://purl.oclc.org/dsdl/schematron"?><article xmlns="http://docbook.org/ns/docbook" version="5.0">
   <info>
      <title>XQuery in eXist-db</title>
      <date>September 2017</date>
      <keywordset>
         <keyword>TBD</keyword>
      </keywordset>
   </info>

   <!-- ================================================================== -->

   <sect1 xml:id="introduction">
      <title>Introduction</title>

      <para>eXist-db provides strong support for the W3C recommendation of the XQuery language, implementing the XQuery and XPath functions and
        operators. eXist-db builds on the recommendation, adding a rich family of extension functions and other capabilities that allow XQuery
        developers to create powerful applications with eXist-db.</para>
      <note>
         <para>This document is an important reference work intended to help advanced developers to understand eXist-db's implementation of XQuery, but
          for readers who are new to XQuery or programming in general, this document may be too complex. We recommend you start with the resources
          listed in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="learning-xquery.xml">Learning XQuery with eXist-db</link> or <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="development-starter.xml">Getting Started
            with Web Application Development</link>.</para>
      </note>
      <para>To briefly summarize each section's contents: </para>
      <itemizedlist>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#current-status-of-xquery-support">Current Status of XQuery Support</link> describes the precise nature of eXist-db's
              conformance to the XQuery specification.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#function-library">Function Library</link> outlines where to find the library of documentation about the XQuery functions
              built into eXist-db.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#module-system">The Module System</link> outlines the different kind of library modules that eXist-db supports, ranging
              from modules written in XQuery to those written in Java, and how to register modules as globally available, and how to import them by
              URI.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#xquery-caching">XQuery Caching</link> describes how eXist-db uses caching to improve performance when reusing
              modules.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#extension-functions">eXist-db Extension Functions</link> describes some of the convenient functions available in eXist-db
              for addressing documents and collections.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#calling-java">Calling Java Methods from XQuery</link> describes how enable Java binding to call arbitrary Java methods
              directly from XQuery.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#modules">Creating XQuery Modules</link> describes how to create XQuery Modules in XQuery and Java.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#collations">Using Collations</link> describes how to specify language-specific string sorting and comparisons.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#serialization">Serialization Options</link> explains how to control the output of a query.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#pragmas">Pragmas</link> describes the pragmas that eXist-db implements.</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#other-options">Other Options</link> describes how to set timeouts and other limits and variables on a query.</para>
         </listitem>
      </itemizedlist>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="current-status-of-xquery-support">
      <title>Current Status of XQuery Support</title>

      <para>eXist-db fully implements the XQuery 1.0 language as specified in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/">W3C
        recommendation</link>, with the exception of features <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#unsupported-features">detailed below</link>. Functions in the standard
        function library follow the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xpath-functions/">"XQuery 1.0 and XPath 2.0 Functions and Operators"
          recommendation</link>; see the eXist-db <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/exist/apps/fundocs">XQuery Function Documentation</link>.</para>
      <para>eXist-db also implements most features of the current <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/">"XQuery 3.0"</link> Working Draft, as
        detailed in the section on <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#xquery-30">XQuery 3 support</link> below. From <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#xquery-31">XQuery 3.1</link>, the map
        data type is fully supported. An implementation of arrays is in the works.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="xqts">
         <title>XQuery Test Suite compliance</title>

         <para>The eXist-db XQuery implementation is tested against the official <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://dev.w3.org/2006/xquery-test-suite/">XML Query Test
            Suite (XQTS)</link>. This suite, which focuses on XQuery 1.0, contains more than 14,000 tests, and eXist-db passes more than 99.4% of the
          tests. We are continuously trying to improve these results. The <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://dev.w3.org/2011/QT3-test-suite/">XQuery 3.0 Test Suite
            (QT3)</link> has just become available and has been integrated into our test harness, though the results are not reliable yet.</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="supported-optional-features">
         <title>Supported Optional Features</title>

         <para>In addition to the standard features, eXist-db provides extended support for <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#module-system">
               <emphasis>modules</emphasis>
            </link> and implements the <emphasis>full axis</emphasis> feature, which means you can use the <emphasis>optional axes</emphasis>:
            <literal>ancestor</literal>, <literal>ancestor-or-self</literal>, <literal>following</literal>, <literal>following-sibling</literal>,
            <literal>preceding</literal>, and <literal>preceding-sibling</literal>. (The only optional axis not supported is the
            <literal>namespace</literal> axis.)</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="unsupported-features">
         <title>Unsupported features</title>

         <para>eXist-db implements all features described in the XQuery 1.0 specification, with the exception of the following:</para>
         <itemizedlist>
            <listitem>
               <para>Schema-related Features (<literal>validate</literal> and <literal>import schema</literal>). eXist-db's XQuery processor does
              currently not support the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-schema-import-feature">schema import</link> and <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-schema-validation-feature">schema validation features</link> defined as <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-conform-optional-features">optional</link> in the XQuery specification. eXist-db provides <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{${fundocs.pkg.abbrev}}/view.html?uri=http://exist-db.org/xquery/validation&amp;location=java:org.exist.xquery.functions.validation.ValidationModule">extension functions</link> to perform XML validation. The database does not store type information along with the nodes. It
              therefore cannot know the typed value of a node and has to assume <literal>xs:untypedAtomic</literal>. This is the behaviour defined by
              the XQuery specification.</para>
            </listitem>
            <listitem>
               <para>eXist-db does not support specifying a data type in an element or attribute test. The node test
                <literal>element(test-node)</literal> is supported, but the test <literal>element(test-node, xs:integer)</literal> will result in a
              syntax error.</para>
            </listitem>
         </itemizedlist>
         <para>eXist-db does nevertheless support strong typing whenever the expected type of an expression, a function argument or function return
          value is explicitly specified or can be known otherwise. eXist-db is not lax about type checks.</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="xquery-30">
         <title>XQuery 3.0 Support</title>

         <para>eXist-db implements the following features of the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/">"XQuery 3.0"</link> Working Draft</para>
         <itemizedlist>
            <listitem>
               <para>Higher Order Functions: eXist-db completely supports higher-order functions, including features like inline functions, closures, and
              partial function application. For more information, see the article on the eXist-db blog, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://atomic.exist-db.org/blogs/eXist/HoF">Higher-Order Functions in XQuery 3.0</link>
               </para>
            </listitem>
            <listitem>
               <para>Group by clause in FLWOR expressions: "group by" provides an efficient way to group the sequences generated in a FLWOR expression.
              For example,</para>
               <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-1.txt"/>
               <para>queries the Shakespeare plays and groups the result by speaker.</para>
            </listitem>
            <listitem>
               <para>Try/Catch: The try/catch expression provides error handling for dynamic errors and type errors. For example,
              </para>
               <programlisting language="xquery">try { 'a' + 7 } catch * { concat($err:code, ": ", $err:description) }</programlisting>
               <para> returns the full error
              (excerpted here): </para>
               <programlisting>err:XPTY0004: It is a type error if...</programlisting>
               <para> For more information, see the article on the eXist-db
              blog, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://atomic.exist-db.org/HowTo/XQuery3/Try-CatchExpression">Try-Catch Expression</link> and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/#id-try-catch">specification</link>.</para>
            </listitem>
            <listitem>
               <para>The new String Concatenation expression: A convenient alternative to the <literal>concat()</literal> function. Strings can be joined
              with </para>
               <programlisting>||</programlisting>
               <para>. For example, </para>
               <programlisting language="xquery">"Hello " || $world || "!"</programlisting>
               <para> is equivalent to
              </para>
               <programlisting language="xquery">concat("Hello", $world, "!")</programlisting>
               <para>. See the original <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://markmail.org/message/a7dmmhixwbbnwikt">announcement</link> on exist-open and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/#id-string-concat-expr">specification</link>.</para>
            </listitem>
            <listitem>
               <para>The Simple Map Operator: Can be used to replace short "for" loops, providing performance benefits due to its simpler processing
              compared to a full "for" statement. In an example like
              </para>
               <programlisting language="xquery">("red", "blue", "green") ! string-length() ! (. * 2)</programlisting>
               <para>, the right-hand expression is evaluated once
              for each item in the sequence to the left of "!". The example results in </para>
               <programlisting>6, 8, 10</programlisting>
               <para>. See the original <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://markmail.org/message/a7dmmhixwbbnwikt">announcement</link> on exist-open and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/#id-map-operator">specification</link>.</para>
            </listitem>
            <listitem>
               <para>Switch expression: Eliminates the need for long conditional chains for string values. See the article on the eXist-db blog, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://atomic.exist-db.org/HowTo/XQuery3/SwitchExpressionExample">Switch Expression</link>, and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/#id-switch">specification</link>.</para>
            </listitem>
            <listitem>
               <para>New functions: XQuery 3.0 adds a number of functions, some previously available only in XSLT are now available in XQuery 3.0. See,
              for example, the specification on <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xpath-functions-30/#rules-for-datetime-formatting">date/time
                formatting functions</link> like <literal>fn:format:date()</literal>, <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xpath-functions-30/#formatting-numbers">formatting numbers</link> like
                <literal>fn:format-number()</literal>, and <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xpath-functions-30/#func-analyze-string">fn:analyze-string()</link>.</para>
            </listitem>
            <listitem>
               <para>Private functions and function annotations: Annotations declare properties associated with functions and variables. For example,
              functions can now be declared as %private or %public. See the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-30/#id-annotations">specification</link>. </para>
            </listitem>
            <listitem>
               <para>Serialization Parameters: XQuery 3.0 version of the language provides a standard way to set serialization parameters. The old,
              non-standard approach in eXist-db was to use a single option with all parameters in the value:
              </para>
               <programlisting language="xquery">declare option exist:serialize "method=json media-type=application/json";</programlisting>
               <para> The standard way of
              doing this in XQuery 3.0 would be:
              </para>
               <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-10.txt"/>
               <para>
              See the original <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://markmail.org/message/ojasso6drkpbxemz">announcement</link> on exist-open and the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xslt-xquery-serialization-30/">specification</link>
               </para>
            </listitem>
         </itemizedlist>
         <para>To make use of these features of XQuery 3.0, use the proper version declaration in the prolog of your queries:</para>
         <programlisting>xquery version "3.0";</programlisting>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>Missing XQuery 3.0 Features</title>

         <para>eXist-db 2.0 does not support some of the less frequently used XQuery 3.0 constructs, mainly because we did not encounter many use cases
          for them yet. This may certainly change though:</para>
         <itemizedlist>
            <listitem>
               <para>"tumbling" and "sliding window" in FLWOR expressions</para>
            </listitem>
            <listitem>
               <para>"count" clause in FLWOR expressions</para>
            </listitem>
            <listitem>
               <para>"allowing empty" in FLWOR clause</para>
            </listitem>
         </itemizedlist>
         <para>The following functions from the XQuery 3.0 function specification are missing as well, but most of them are in fact just replacements
          for functions which have been available in eXist-db since a long time:</para>
         <table>
            <title>Unsupported XQuery 3.0 Functions</title>

            <tgroup cols="3">
               <colspec colname="c1" colnum="1" colwidth="1.0*"/>
               <colspec colname="c2" colnum="2" colwidth="1.0*"/>
               <thead>
                  <row>
                     <entry>
                        <para>XQuery 3.0</para>
                     </entry>
                     <entry>
                        <para>eXist-db 2.0</para>
                     </entry>
                     <entry/>
                  </row>
               </thead>
               <tbody>
                  <row>
                     <entry>
                        <para>unparsed-text</para>
                     </entry>
                     <entry>
                        <para>util:binary-to-string(util:binary-doc($doc))</para>
                     </entry>
                     <entry/>
                  </row>
                  <row>
                     <entry>
                        <para>unparsed-text-available</para>
                     </entry>
                     <entry>
                        <para>util:binary-doc-available</para>
                     </entry>
                     <entry/>
                  </row>
                  <row>
                     <entry>
                        <para>unparsed-text-lines</para>
                     </entry>
                     <entry>
                        <para>na</para>
                     </entry>
                     <entry/>
                  </row>
                  <row>
                     <entry>
                        <para>innermost/outermost</para>
                     </entry>
                     <entry>
                        <para>na</para>
                     </entry>
                  </row>
                  <row>
                     <entry>
                        <para>path</para>
                     </entry>
                     <entry>
                        <para>na</para>
                     </entry>
                     <entry/>
                  </row>
               </tbody>
            </tgroup>
         </table>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="xquery-31">
         <title>XQuery 3.1</title>

         <para>The specification for XQuery 3.1 is still subject to change. The main additions are maps and arrays.</para>
         <sect3>
            <title>Maps</title>

            <para>Maps are fundamental for the templating module and other libraries in eXist 2.2, and are thus very well supported. Over time, the
            specification changed slightly and so did the implementation in eXist. For example, to keep backwards compatibility, eXist allows the
            older notation in map constructors: <code>key:=value</code> in addition to the new one, <code>key: value</code>. Also, some functions in
            eXist support collations, which are no longer in the specification.</para>
            <para>Please refer to the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="{demo}/examples/basic/maps.html">demo app</link> for basic examples.</para>
         </sect3>
         <sect3>
            <title>Arrays</title>

            <para>Support for arrays has been implemented, but it is not in the official codebase yet. We're waiting for the specification to stabilize
            before we'll merge the code into develop.</para>
         </sect3>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="related-specifications">
         <title>Other Related Specifications</title>

         <itemizedlist>
            <listitem>
               <para>Full Text Search: eXist-db has an implementation-specific <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="lucene.xml">Full Text Search facility</link>, built on the
              Lucene library (among several methods of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="indexing.xml">indexing</link>). It does not currently support the syntax in the
              W3C <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xpath-full-text-10/">XQuery and XPath Full Text 1.0</link> Recommendation.</para>
            </listitem>
            <listitem>
               <para>XQuery Update: eXist-db has an implementation-specific <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="update_ext.xml">XQuery Update syntax</link>. It does not
              currently support the syntax in the W3C <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery-update-10/">XQuery Update Facility 1.0</link>
              Recommendation. The main difference is that the eXist-db implementation supports in-place updates. Switching to the W3C recommendation
              would break backwards compatibility. We postponed this step to after 2.0.</para>
            </listitem>
         </itemizedlist>
      </sect2>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="function-library">
      <title>Function Library</title>

      <para>A complete list of XQuery functions supported by eXist-db <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="/exist/apps/fundocs">XQuery Function Documentation</link>. Each
        module's documentation is generated from a different sources, depending on whether the module is implemented in Java or XQuery. For modules
        implemented in Java, the documentation are taken directly from the signature provided by the class implementing the
          <literal>Function</literal> interface. For modules implemented in XQuery, the function descriptions are taken from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="xqdoc.xml">XQDoc-formatted comments and annotations</link>.</para>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="module-system">
      <title>The Module System</title>

      <para>With eXist-db, you can write <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="development-starter.xml">entire web applications in XQuery</link>. This may result in rather
        complex XQuery scripts, consisting of several thousand lines of code. Being able to package related functions into modules is thus an
        important feature. eXist-db allows modules to be imported from a variety of sources:</para>
      <itemizedlist>
         <listitem>
            <para>an URI</para>
         </listitem>
         <listitem>
            <para>a collection in the database</para>
         </listitem>
         <listitem>
            <para>a jar file, i.e. a Java archive</para>
         </listitem>
         <listitem>
            <para>a Java class, if the module is itself implemented in Java</para>
         </listitem>
      </itemizedlist>
      <para>For example, a typical import statement in an XQuery will look like this:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-12.txt"/>
      <para>Provided that the module namespace does not point to one of the preloaded standard modules (see below), the query engine will try to
        locate the module source by looking at the URI given after the <literal>at</literal> keyword. In the example above, the module was specified
        using a full URI and the query engine will attempt to load the module source from the given URI. However, the module could also be stored in a
        database collection:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-13.txt"/>
      <para>The query engine recognizes that the module should be stored in the local database instance and tries to directly compile it from
        there.</para>
      <para>If the XQuery module is part of a Java application, it might also be an option, to pack the module into a Java archive (.jar file) along
        with the Java classes and use the following import to load the module from a Java package:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-14.txt"/>
      <para>Finally, XQuery modules can also be implemented in Java (see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#calling-java">below</link>), in which case you can import them
        by specifying the class path of the Module class:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-15.txt"/>
      <para>The <literal>extensions/modules</literal> directory in the eXist-db distribution contains a number of useful modules, which could also
        serve as examples for implementing your own.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>Using Relative URIs</title>

         <para>If the location specified in an import statement is a relative URI, the query engine will try to load the module relatively to the
          current module load path. The module load path is determined as follows:</para>
         <orderedlist>
            <listitem>
               <para>if the main XQuery was retrieved from the file system, the module load path points to that directory. This applies to queries
              executed through the XQueryServlet, XQueryGenerator or the Java admin client.</para>
            </listitem>
            <listitem>
               <para>if the main XQuery was loaded from a database collection, the module load path is the URI of that collection.</para>
               <para>For example, if you access an XQuery via the REST server:</para>
               <programlisting>http://localhost:8080/exist/servlet/db/modules/test.xq</programlisting>
               <para>All relative module paths will be resolved relative to the <literal>/db/modules</literal> collection.</para>
            </listitem>
         </orderedlist>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>Preloaded Modules</title>

         <para>Preloaded modules do not need to be explicitly imported or declared in the prolog of queries. The <tag>builtin-modules</tag>
          element in <literal>conf.xml</literal> lists the namespaces and the corresponding Java class that implements the module of all modules to
          be preloaded:</para>
         <example>
            <title>Auto-loaded Modules</title>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xml" xlink:href="listings/listing-17.xml"/>
         </example>
      </sect2>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="xquery-caching">
      <title>XQuery Caching</title>

      <para>XQuery modules executed via the REST interface, the XQueryServlet or XQueryGenerator are <emphasis>automatically</emphasis> cached: the
        compiled expression will be added to an internal pool of prepared queries. The next time a query or module is loaded from the same location,
        it will not be compiled again. Instead, the already compiled code is reused. The code will only be recompiled if eXist-db decides that the
        source was modified or it wasn't used for a longer period of time.</para>
      <para>If a query is accessed by more than one thread concurrently, each new thread will create a new copy of the compiled query. The copies will
        be added to the query pool until it reaches a pre-defined limit.</para>
      <para>Modules are cached along with the main query that imported them.</para>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="extension-functions">
      <title>eXist-db Extension Functions</title>

      <para>eXist-db offers a number of additional functions. While the XQuery Function Documentation lists them all, several possess articles of
        their own discussing some of the essential uses in detail:</para>
      <itemizedlist>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="xmldb.xml">xmldb</link>: A module for manipulating database contents</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="util.xml">util</link>: A module containing several convenient utility functions</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="kwic.xml">kwic</link>: A module that provides keyword in context (KWIC) highlighting functions</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="lucene.xml">ft</link>: A module for accessing the full text index, built on the Lucene library</para>
         </listitem>
         <listitem>
            <para>
              <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="contentextraction.xml">contentextraction</link>: A module for extracting content from binary files</para>
         </listitem>
      </itemizedlist>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="calling-java">
      <title>Calling Java Methods from XQuery</title>

      <para>eXist-db supports calls to arbitrary Java methods from within XQuery. The binding mechanism follows the short-cut technique introduced by
          <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://saxon.sf.net">Saxon</link>. The class where the external function will be found is identified by the namespace URI of
        the function call. The namespace URI should start with the prefix <literal>java:</literal> followed by the fully qualified class name of the
        class. For example, the following code snippet calls the static method <literal>sqrt</literal> (square-root function) of class
          <literal>java.lang.Math</literal>:</para>
      <example>
         <title>Calling a Static Method</title>
         <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-18.txt"/>
      </example>
      <para>Note that if the function name contains a hyphen, the letter following the hyphen is converted to upper-case and the hyphen is removed
        (i.e. it applies the CamelCase naming convention), and so, <code>to-string()</code> will call the Java method <code>toString()</code>.</para>
      <para>If more than one method in the class matches the given name and parameter count, eXist-db tries to select the method that best fits the
        passed parameter types at runtime. The result of the method call can be assigned to an XQuery variable. If possible, it will be mapped to the
        corresponding XML schema type. Otherwise, it's type is the built-in type <literal>object</literal>.</para>
      <para>
        <emphasis>Java constructors</emphasis> are called using the function <literal>new</literal>. Again, a matching constructor is selected by
        looking at the parameter count and types. The returned value is a new Java object with the built-in type <literal>object</literal>.</para>
      <para>
        <emphasis>Instance methods</emphasis> are called by supplying a valid Java object as first parameter. The Java object has to be an instance of
        the given class. For example, the following snippet lists all files and directories in the current directory:</para>
      <example>
         <title>List Contents of the Current Directory</title>
         <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-19.txt"/>
      </example>
      <note>
         <para>For security reasons, the Java binding is disabled by default. To enable it, the attribute <literal>enable-java-binding</literal> in the
          central configuration file has to be set to <literal>yes</literal>: </para>
         <programlisting>&lt;xquery enable-java-binding="yes"&gt;</programlisting>
         <para>Enabling the Java binding bears some risks: if you allow users to directly pass XQuery code to the database, e.g. through the sandbox
          application, they might use Java methods to inspect your system or execute potentially destructive code on the server.</para>
      </note>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="modules">
      <title>Creating XQuery Modules</title>

      <para>eXist-db supports XQuery library modules. These modules are simply collections of function definitions and global variable declarations,
        of which eXist-db knows two types: <emphasis>External Modules</emphasis>, which are themselves written in XQuery, and <emphasis>Internal
          Modules</emphasis>, which are implemented in Java. The standard XPath/XQuery functions and all extension functions described in the above
        sections are implemented as internal modules. This section describes how to create XQuery modules using XQuery and Java.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="xquery-modules">
         <title>Creating Modules in XQuery</title>

         <para>You can declare an XQuery file as a module and import it using the <literal>import module</literal> directive. The XQuery engine imports
          each module only once during compilation. The compiled module is then made available through the static XQuery context.</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="java-modules">
         <title>Creating Modules in Java</title>

         <para>To register a Java-based XQuery modules, eXist-db requires a namespace URI by which the module is identified, and the list of functions
          it supplies. For this, you need only to pass a driver class to the XQuery engine, and this class should implement the interface
            <literal>org.exist.xpath.InternalModule</literal>.</para>
         <note>
            <para>Besides the basic methods for creating a Java-based XQuery module as described here, eXist-db provides a pluggable module interface
            that allows extension modules to be easily developed in Java. See <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="extensions.xml">XQuery Extension Modules</link> for the
            full documentation on this eXist-db development best practice.</para>
         </note>
         <para>Moreover, the class <literal>org.exist.xpath.AbstractInternalModule</literal> already provides an implementation skeleton. The class
          constructor expects an array of function definitions for all functions that should be registered. A function definition (class
            <literal>FunctionDef</literal>) has two properties: the static signature of the function (as an instance of
            <literal>FunctionSignature</literal>), and the Java Class that implements the function.</para>
         <para>A function is a class extending <literal>org.exist.xquery.Function</literal> or
            <literal>org.exist.xquery.BasicFunction</literal>. Functions without special requirements (e.g. overloading) should subclass
          BasicFunction. To illustrate, the following is a simple function definition:</para>
         <example>
            <title>A Basic Java Function</title>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="java" xlink:href="listings/listing-21.txt"/>
         </example>
         <para>In looking at this sample, first note that every function class has to provide a function <emphasis>signature</emphasis>. The function
          signature defines the <emphasis>QName</emphasis> by which the function is identified, a documentation string, the sequence types of all
          arguments, and the sequence type of the returned value. In the example above, we accept a single argument named "text" of type
            <literal>xs:string</literal> and a cardinality of <literal>ZERO_OR_MORE</literal> with the description "The text to echo". In other words, we
          accept any sequence of strings containing zero or more items. The return value is of type <literal>xs:string</literal> and a cardinality of
            <literal>ZERO_OR_MORE</literal> with the description "the echoed text". <emphasis role="bold">Note:</emphasis> The parameter description
          should be normal sentence starting with a capital letter. The return value description is always prepended with "Returns ", so have the text
          to match. </para>
         <para>Next, the subclass overwrites the <literal>eval</literal> method, which has two arguments: the first contains the values of all
          arguments passed to the function, the second passes the current context sequence (which might be null). Note that the argument values in the
          array <literal>args</literal> have already been checked to match the sequence types defined in the function signature. We therefore do not
          have to recheck the length of the array: if more or less than one argument were passed to the function, an exception would have been thrown
          before eval gets called.</para>
         <para>In XQuery, all values are passed as sequences. A sequence consists of one or more items, and every item is either an atomic value or a
          node. Furthermore, a single item is also a sequence. The function signature specifies that any sequence containing zero or more strings is
          acceptable for our method. We therefore have to check if the empty sequence has been passed. In this case, the function call returns
          immediately. Otherwise, we iterate through each item in the sequence, prepend <literal>echo:</literal>" to its string value, and add it to the
          result sequence.</para>
         <para>In the next step, we want to add the function to a new module, and therefore provide a driver class. The driver class defines a
          namespace URI and a default prefix for the module. Functions are registered by passing an array of <literal>FunctionDef</literal> to the
          constructor. The following is an example driver class definition:</para>
         <example>
            <title>Creating a Driver Class</title>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="java" xlink:href="listings/listing-22.txt"/>
         </example>
         <para>Finally, we are able to use this newly created module in an XQuery script:</para>
         <example>
            <title>Importing a Module</title>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-23.txt"/>
         </example>
         <para>The query engine recognizes the <literal>java:</literal> prefix in the location URI, and treats the remaining part (in this case,
            <literal>org.exist.examples.xquery.ExampleModule</literal>) as a fully qualified class name leading to the driver class of the
          module.</para>
      </sect2>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="collations">
      <title>Collations</title>

      <para>Collations are used to compare strings in a <emphasis>locale-sensitive</emphasis> fashion. XQuery allows one to specify collations at
        several places by means of a collation URI. For example, a collation can be specified in the <literal>order by</literal> clause of a XQuery
        FLWOR expression, as well as any string-related functions. However, the concrete form of the URI is defined by the eXist-db implementation.
        Specifically, eXist-db recognizes the following URIs:</para>
      <orderedlist>
         <listitem>
            <programlisting>http://www.w3.org/2005/xpath-functions/collation/codepoint</programlisting>
            <para>This URI selects the unicode codepoint collation. This is the default if no collation is specified. Basically, it means that only the
            standard Java implementations of the comparison and string search functions are used.</para>
         </listitem>
         <listitem>
            <programlisting>http://exist-db.org/collation?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</programlisting>
            <para>or, in a simpler form:</para>
            <programlisting>?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</programlisting>
            <para>The <literal>lang</literal> parameter selects a locale, and should have the same form as in <literal>xml:lang</literal>. For example, we
            may specify "de" or "de-DE" to select a german locale.</para>
            <para>The <literal>strength</literal> parameter (optional) value should be one of "primary", "secondary", "tertiary" or "identical".</para>
            <para>The decomposition parameter (optional) has the value of "none", "full" or "standard".</para>
         </listitem>
      </orderedlist>
      <para>The following example selects a german locale for sorting:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-27.txt"/>
      <para>And returns the following:</para>
      <programlisting>Bauer, Bäuerin, Buch, Bücher, das, daß, Jagen, Jäger</programlisting>
      <para>You can also change the default collation:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-29.txt"/>
      <para>Which returns <literal>true</literal>. Note that if you use the default codepoint collation instead, the comparison would evaluate to
          <literal>false</literal>.</para>
      <para>You can also use java class specified collators. They should be subclassing <literal>java.text.RuleBasedCollator</literal>. It will be used
        like this:</para>
      <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-30.txt"/>
      <para>The jar with the .class file(s) of the collator needs to be in <literal>${EXIST_HOME}/lib/user</literal>
      </para>
      <note>
         <para>eXist-db's range index is currently only usable with the default codepoint collation. This means that comparisons using a different
          collation will not be index-assisted and will thus be slow. Collation-aware indexes may be added in the future.</para>
      </note>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="serialization">
      <title>Serialization Options</title>

      <para>The serialization of query results into a binary stream is influenced by a number of parameters. These parameters can be set within the
        query itself, however the interpretation of the parameters depends on the context in which the query is called. Most output parameters are
        applicable only if the query is executed using the XQueryGenerator or XQueryServlet servlets, or the REST server.</para>
      <para>In XQuery 1.0, serialization parameters were implementation defined, and eXist-db developed its own set of parameters. In XQuery 3.0,
        serialization is standardized in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xslt-xquery-serialization-30/">specification</link>.</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="serialization-10">
         <title>Serialization in XQuery 1.0</title>

         <para>In XQuery 1.0, serialization parameters can be set by <literal>declare option</literal> statement in the query prolog. In <literal>declare
            option</literal>, the serialization parameters can be specified as follows:</para>
         <programlisting>declare option exist:serialize "method=xhtml media-type=application/xhtml+html";</programlisting>
         <para>Here, single options are specified within the string literal, separated by a whitespace. Note also that the option QName must be
            <literal>exist:serialize</literal>, where the <literal>exist</literal> prefix is bound to the namespace
            <literal>http://exist.sourceforge.net/NS/exist</literal>, which is declared by default and need not be specified explicitly.</para>
         <para>Note that these same options can be passed using the <literal>XPathQueryService.setProperty()</literal> and
            <literal>XQueryService.setProperty()</literal> methods in Java. These methods are defined in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/OutputKeys.html">
               <literal>javax.xml.transform.OutputKeys</literal>
            </link> and <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://exist-db.org/api/org/exist/storage/serializers/EXistOutputKeys.html">
               <literal>EXistOutputKeys</literal>
            </link>. The latter eXist-specific options include the following:</para>
         <variablelist spacing="compact">
            <varlistentry>
               <term>
                  <literal>expand-xincludes= yes | no</literal>
               </term>
               <listitem>
                  <para>should the serializer expand XInclude elements?</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>highlight-matches= both | elements | attributes | none</literal>
               </term>
               <listitem>
                  <para>when querying text with the full text or n-gram extensions, the query engine tracks the exact position of all matches inside text
                content. The serializer can later use this information to mark those matches by wrapping them into an element
                  <tag>exist:match</tag>.</para>
                  <para>Setting <literal>highlight-matches=both</literal> will enable this feature for every kind of indexable node.</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>process-xsl-pi= yes | no</literal>
               </term>
               <listitem>
                  <para>if a document is serialized and it has an XSL processing instruction, eXist-db can try to load the referenced stylesheet and apply
                it to the document.</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>add-exist-id= element | all | none</literal>
               </term>
               <listitem>
                  <para>shows the internal node ids of an element by adding an attribute <literal>exist:id="internal-node-id"</literal>. Setting
                add-exist-id to "element" will only show the node id of the top-level element, "all" will show the ids of all elements.</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>json-ignore-whitespace-text-nodes= yes | no</literal>
               </term>
               <listitem>
                  <para>to discard white-space text nodes when serializing XML/XDM to JSON.</para>
               </listitem>
            </varlistentry>
         </variablelist>
         <para>The general options include the following:</para>
         <variablelist spacing="compact">
            <varlistentry>
               <term>
                  <literal>method= xml | xhtml | json | text</literal>
               </term>
               <listitem>
                  <para>determines the serialization method. Should be one of "xml", "xhtml", "json", or "text". The "xhtml" method makes sure that XHTML
                elements with an empty content model are serialized in the minimized form, i.e. <literal>img</literal> will be output as
                  <tag>img/</tag>. </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>jsonp= myFunctionName</literal>
               </term>
               <listitem>
                  <para>Only relevant when the serialization method is set to 'json'. Causes the JSON output to be wrapped in the named JSONP function.
              </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>media-type</literal>
               </term>
               <listitem>
                  <para>The MIME content type of the output. It will mainly be used to set the HTTP Content-Type header (if the query is running in an
                HTTP context).</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>encoding</literal>
               </term>
               <listitem>
                  <para>specifies the character encoding to be used for outputting the instance of the data model</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>doctype-public</literal>
               </term>
               <listitem>
                  <para>a doctype declaration will be output if doctype-public and/or doctype-system are set. The corresponding identifier is taken from
                the value of the parameter.</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>doctype-system</literal>
               </term>
               <listitem>
                  <para>a doctype declaration will be output if doctype-public and/or doctype-system are set. The corresponding identifier is taken from
                the value of the parameter.</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>indent= yes | no</literal>
               </term>
               <listitem>
                  <para>indent the document to make it easier to read. Indenting adds whitespace characters to element nodes, restricted by the rules
                given in the XQuery serialization spec.</para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>omit-xml-declaration= yes | no</literal>
               </term>
               <listitem>
                  <para>output an XML declaration if the parameter is set to "no"</para>
               </listitem>
            </varlistentry>
         </variablelist>
         <para>For example, to disable XInclude expansion, and indent the output, you can use the following syntax:</para>
         <programlisting>declare option exist:serialize "expand-xincludes=no indent=yes";</programlisting>
         <para>For the output method parameter, eXist-db currently recognizes three methods: <literal>xml</literal>, <literal>xhtml</literal> and
            <literal>text</literal>. Note that unlike the xml method, the xhtml setting uses only the short form for elements that are declared empty in
          the xhtml DTD. For example, the <literal>br</literal> tag is always returned as &lt;br/&gt;. On the other hand, the text method only returns
          the contents of elements - for instance, &lt;A&gt;Content&lt;/A&gt; is returned as <literal>Content</literal>. However, attribute values,
          processing instructions, comments, etc. are all ignored.</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="serialization-30">
         <title>Serialization in XQuery 3.0</title>

         <para>XQuery 3.0 version of the language provides a standard way to set serialization parameters. The old, non-standard approach in eXist-db
          was to use a single option with all parameters in the value:
          </para>
         <programlisting language="xquery">declare option exist:serialize "method=json media-type=application/json";</programlisting>
         <para> The standard way of doing
          this in XQuery 3.0 would be:
          </para>
         <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xquery" xlink:href="listings/listing-34.txt"/>
         <para>The old approach is still supported for backwards compatibility. The parameter names remain the same as well.</para>
      </sect2>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="pragmas">
      <title>Pragmas</title>

      <para>XQuery pragmas are a way to pass implementation-specific information to the query engine from within a XQuery. The syntax for pragmas has
        changed between the different drafts of the XQuery specification. In earlier eXist-db releases, pragmas were used similar to what is now the
        "declare option" prolog expression. The new syntax is quite different: pragmas can now be wrapped around an arbitrary XQuery expression (see
        the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#id-extension-expressions">specification</link>). </para>
      <para>Currently, eXist-db recognizes the following pragmas:</para>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>exist:timer</title>

         <para>Provides a simple way to measure the time for executing a given expression. For example:</para>
         <programlisting>(# exist:timer #) { //some/path/expression }</programlisting>
         <para>creates a timer for the expression enclosed in curly braces and prints timing information to the trace logger. Please note that trace
          needs to be enabled in <literal>log4j.xml</literal>:</para>
         <example>
            <title>Configure log4j to Display Trace Output</title>
            <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" language="xml" xlink:href="listings/listing-36.xml"/>
         </example>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>exist:batch-transaction</title>

         <para>
            <emphasis>Currently only for XQuery Update Extensions.</emphasis> Provides a method for batching updates on the database into a single
          Transaction, allowing a set of updates to be atomically guaranteed. Also for each affected document or collection, any configured Triggers
          will only be called once, the <literal>prepare()</literal> method will be fired before the first update to the configured resource and
          the <literal>finish()</literal> method fired after the last update to the configured resource.</para>
         <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="listings/listing-37.txt"/>
         <para>Uses a single Transaction and Trigger events for the expressions enclosed in curly braces.</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>exist:force-index-use</title>

         <para>
            <emphasis>For debugging purposes</emphasis>. An expression that can be assisted by indexes: comparisons,
          <literal>fn:matches()</literal>... Will raise an error if, for any reason, this assistance can not be performed.</para>
         <para>This can help to check whether the indexes are correctly defined or not.</para>
         <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="listings/listing-38.txt"/>
         <para>Raises an error (currently <emphasis>XPDYxxxx</emphasis> since this kind of dynamic error is not yet defined by the XQuery
          specifications) if the general comparison doesn't use a range or a QName index.</para>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>exist:no-index</title>

         <para>This prevents the query engine to use the index in expressions that can be assisted by indexes: comparisons,
            <literal>fn:matches()</literal>... Useful if the searched value isn't very selective or if it is cheaper to traverse the previous step
          of a path expression than querying the index.</para>
         <programlisting xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="listings/listing-39.txt"/>
      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2>
         <title>exist:optimize</title>

         <para>For testing only. This pragma is normally inserted automatically by the query rewriter (if enabled) to optimize an expression that
          implements the <literal>org.exist.xquery.Optimizable</literal> interface.</para>
         <programlisting>//((#exist:optimize#) { item[stock = 10] })</programlisting>
         <para>We will certainly add more pragma expressions in the near future. Among other things, pragmas are a good way to pass optimization hints
          to the query engine.</para>
      </sect2>
   </sect1>

   <!-- ================================================================== -->

   <sect1 xml:id="other-options">
      <title>Other Options</title>

      <para>To prevent the server from being blocked by a badly formulated query, eXist-db watches all query threads. A blocking query can be killed
        if it takes longer than a specified amount of time or consumes too many memory resources on the server. There are two options to control this
        behaviour:</para>
      <programlisting>declare option exist:timeout "time-in-ms";</programlisting>
      <para>Specifies the maximum amount of query processing time (in ms) before it is cancelled by the XQuery engine.</para>
      <programlisting>declare option exist:output-size-limit "size-hint";</programlisting>
      <para>Defines a limit for the max. size of a document fragment created within an XQuery. The limit is just an estimation, specified in terms of
        the accumulated number of nodes contained in all generated fragments. This can be used to prevent users from consuming too much memory if they
        are allowed to pass in their own XQueries.</para>
      <programlisting>declare option exist:implicit-timezone "duration";</programlisting>
      <para>Specifies the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#dt-timezone">implicit timezone</link> for the XQuery context.</para>
      <programlisting>declare option exist:current-dateTime "dateTime";</programlisting>
      <para>Specifies the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.w3.org/TR/xquery/#GLdt-date-time">current dateTime</link> for the XQuery context.</para>
      <programlisting>declare option exist:optimize "enable=yes|no";</programlisting>
      <para>Temporarily disables the query rewriting optimizer for the current query. Use for testing/debugging.</para>
   </sect1>
</article>
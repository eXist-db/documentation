<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng"
        schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml"
        schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.0">
  <info>
    <title>XQuery in eXist-db</title>
    <date>1Q18</date>
    <keywordset>
      <keyword>xquery</keyword>
    </keywordset>
  </info>

  <!-- ================================================================== -->

  <para>eXist-db provides strong support for the W3C's family of recommendations for the XQuery
    language. eXist-db also supports a rich family of extension functions and capabilities, enabling
    XQuery developers to create powerful applications.</para>
  <para>This document is intended for advanced developers and explains eXist-db's implementation of
    XQuery. For readers who are new to XQuery or programming in general we recommend you start with
    the resources listed in <link xlink:href="learning-xquery">Learning XQuery with eXist-db</link>
    or <link xlink:href="development-starter">Getting Started with Web Application
      Development</link>.</para>

  <!-- ================================================================== -->

  <sect1 xml:id="current-status-of-xquery-support">
    <title>Current Status of XQuery Support</title>

    <para>eXist-db implements <link xlink:href="http://www.w3.org/TR/xquery/" condition="_blank"
        >XQuery 3.1: An XML Query Language</link> and <link
        xlink:href="http://www.w3.org/TR/xpath-functions/" condition="_blank">"XPath and XQuery
        Functions and Operators 3.1"</link>, with the exception of certain <link
        xlink:href="#unsupported-features">unsupported features and functions</link>. For complete
      documentation on functions in eXist-db, see <link xlink:href="/exist/apps/fundocs"
        condition="_blank">XQuery Function Documentation</link>.</para>
    <para>eXist-db's XQuery implementation has been tested against the official <link
        xlink:href="http://dev.w3.org/2006/xquery-test-suite/" condition="_blank">XML Query Test
        Suite (XQTS)</link>. An updated test suite runner to test conformance against the official
        <link xlink:href="https://dev.w3.org/2011/QT3-test-suite/" condition="_blank"
        >XQuery/XPath/XSLT 3.* Test Suite (QT3)</link> is being planned.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="supported-optional-features">
      <title>Supported Optional Features</title>

      <para>In addition to the standard features, eXist-db provides extended support for <link
          xlink:href="#module-system">
          <emphasis>modules</emphasis>
        </link>.</para>
      <para>It implements the <emphasis>full axis</emphasis> feature, providing support for the
        following <emphasis>optional axes</emphasis>: <literal>ancestor::</literal>,
          <literal>ancestor-or-self::</literal>, <literal>following::</literal>,
          <literal>following-sibling::</literal>, <literal>preceding::</literal> and
          <literal>preceding-sibling::</literal>. The only optional axis not supported is the
          <literal>namespace</literal> axis.</para>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="unsupported-features">
      <title>Unsupported features</title>

      <para>eXist-db supports strong typing whenever the expected type of an expression, function
        argument, or function return value is explicitly specified or can be known otherwise.
        However, the following schema- and data type-related features are not supported:</para>
      <itemizedlist>
        <listitem>
          <para>
            <link xlink:href="http://www.w3.org/TR/xquery/#id-schema-import-feature"
              condition="_blank">schema import</link> and <link
              xlink:href="http://www.w3.org/TR/xquery/#id-schema-validation-feature"
              condition="_blank">schema validation features</link> (defined as <link
              xlink:href="http://www.w3.org/TR/xquery/#id-conform-optional-features"
              condition="_blank">optional</link> in the XQuery specification). Instead, eXist-db
            provides a <link
              xlink:href="/exist/apps/fundocs/view.html?uri=http://exist-db.org/xquery/validation"
              condition="_blank">validation module</link> containing extension functions to perform
            XML validation.</para>
        </listitem>
        <listitem>
          <para>When storing XML documents, eXist-db does not store type information along with the
            nodes. It therefore doesn't know the typed value of a node and has to assume
              <literal>xs:untypedAtomic</literal> (as defined by the XQuery specification).</para>
        </listitem>
        <listitem>
          <para>eXist-db does not support specifying a data type in an element or attribute test.
            The node test <literal>element(test-node)</literal> is supported, but the type portion
            of the test <literal>element(test-node, xs:integer)</literal> is ignored.</para>
        </listitem>
        <listitem>
          <para>eXist supports all datatypes except <literal>xs:dateTimeStamp</literal>
          </para>
        </listitem>
      </itemizedlist>

      <para>eXist-db supports standard XQuery FLWOR clause constructs except for the
        following:</para>
      <itemizedlist>
        <listitem>
          <para>"tumbling window" and "sliding window" clauses</para>
        </listitem>
        <listitem>
          <para>"count" clause</para>
        </listitem>
        <listitem>
          <para>"allowing empty" clause</para>
        </listitem>
      </itemizedlist>

      <para>eXist-db supports all standard XQuery functions except for the following:</para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>array:put#3</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>array:sort#1, #2, #3</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:collation-key#1, #2</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:contains-token#2, #3</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:default-language#0</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:document-uri#0</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:element-with-id#1, #2</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:format-integer#2, #3</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:json-to-xml#1, #2</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:nilled#0</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:parse-ietf-date#1</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:path#0, #1</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:random-number-generator#0, #1</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:round#2</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:trace#1</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:transform#1</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:uri-collection#0, #1</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>fn:xml-to-json#1, #2</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>map:find#2</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>map:merge#2</literal>
          </para>
        </listitem>
      </itemizedlist>

      <para>eXist-db supports all standard serialization parameters except the following:</para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>item-separator</literal>
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="full-text">
    <title>Full Text Search</title>

    <para>eXist-db has an implementation-specific <link xlink:href="lucene.xml">Full Text Search
        facility</link>, built on the <link xlink:href="https://lucene.apache.org/"
        condition="_blank">Apache Lucene</link> library (see the full documentation on <link
        xlink:href="indexing.xml">indexing</link> in eXist-db). eXist-db does not currently support
      the official W3C <link xlink:href="https://www.w3.org/TR/xpath-full-text/" condition="_blank"
        >"XQuery and XPath Full Text 3.0"</link> specification.</para>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="update">
    <title>XQuery Update</title>

    <para>eXist-db has an implementation-specific <link xlink:href="update_ext.xml">XQuery Update
        facility</link>, which predates the development of the official W3C XQuery Update facility.
      eXist-db does currently not support the official <link
        xlink:href="https://www.w3.org/TR/xquery-update/">"XQuery Update Facility 3.0"</link>
      specification. The main difference between the eXist-db implementation and the official
      specification is that the eXist-db implementation supports in-place updates. Switching to the
      W3C recommendation would break backwards compatibility.</para>

  </sect1>


  <!-- ================================================================== -->

  <sect1 xml:id="function-library">
    <title>Function Library</title>

    <para>A complete list of XQuery functions supported by eXist-db can be found in the <link
        xlink:href="/exist/apps/fundocs" condition="_blank">XQuery Function Documentation</link>. </para>
    <para>Each module's documentation is generated from a different sources, depending on whether
      the module is implemented in Java or XQuery. For modules implemented in Java, the
      documentation is taken directly from the signature provided by the class implementing the
        <literal>Function</literal> interface. For modules implemented in XQuery, the function
      descriptions are taken from <link xlink:href="xqdoc.xml">XQDoc-formatted comments and
        annotations</link>.</para>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="module-system">
    <title>The Module System</title>

    <para>eXist-db supports the creation of <link xlink:href="development-starter.xml">web
        applications in XQuery</link>. This can result in complex XQuery scripts, consisting of
      several thousand lines of code. Packaging related functions in modules is therefore an
      important feature. eXist-db allows modules to be imported from a variety of sources:</para>
    <itemizedlist>
      <listitem>
        <para>an URI</para>
      </listitem>
      <listitem>
        <para>a collection in the database</para>
      </listitem>
      <listitem>
        <para>a jar file, usually a Java archive</para>
      </listitem>
      <listitem>
        <para>a Java class, if the module is implemented in Java itself</para>
      </listitem>
    </itemizedlist>

    <para>For example, a typical import statement in an XQuery will look like this:</para>
    <programlisting language="xquery" xlink:href="listings/listing-12.txt"/>
    <para>Provided the module namespace does not point to one of the preloaded standard modules (see
      below), the query engine will try to locate the module source by looking at the URI given
      after the <literal>at</literal> keyword. In the example above, the module was specified using
      a full URI and the query engine will attempt to load the module source from there. </para>
    <para>However, the module could also be stored in a database collection:</para>
    <programlisting language="xquery" xlink:href="listings/listing-13.txt"/>
    <para>The query engine recognizes the module is stored in the local database instance and tries
      to load it from there.</para>
    <para>If the XQuery module is part of a Java application, it is also an option to pack the
      module into a Java archive (<code>.jar</code> file) along with the Java classes. Then use the
      following <code>import</code> to load it:</para>
    <programlisting language="xquery" xlink:href="listings/listing-14.txt"/>
    <para>Finally, XQuery modules can also be implemented in Java (see <link
        xlink:href="#calling-java">below</link>).You can import them by specifying the class path of
      the Module class:</para>
    <programlisting language="xquery" xlink:href="listings/listing-15.txt"/>
    <para>The <literal>extensions/modules</literal> directory in the eXist-db distribution contains
      a number of useful modules. These can also serve as examples for implementing your own.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2>
      <title>Using Relative URIs</title>

      <para>If the location specified in an import statement is a relative URI, the query engine
        tries to load the module relatively to the current module load path. The module load path is
        determined as follows:</para>
      <orderedlist>
        <listitem>
          <para>If the main XQuery was loaded from a database collection, the module load path is
            the URI of that collection. For example if you access an XQuery via the REST
            server:</para>
          <programlisting>http://localhost:8080/exist/servlet/db/modules/test.xq</programlisting>
          <para>Now all relative module paths will be resolved relative to the
              <literal>/db/modules</literal> collection.</para>
        </listitem>
        <listitem>
          <para>If the main XQuery was retrieved from the file system, the module load path points
            to that directory. This applies to queries executed through the XQueryServlet,
            XQueryGenerator or the Java admin client.</para>
        </listitem>

      </orderedlist>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2>
      <title>Preloaded Modules</title>

      <para>Preloaded modules do not need to be explicitly imported or declared in the prolog of
        queries. The <tag>builtin-modules</tag> element in <literal>conf.xml</literal> lists the
        namespaces and the corresponding Java class that implements all modules to be
        preloaded:</para>
      <programlisting language="xml" xlink:href="listings/listing-17.xml"/>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2>
      <title>EXPath Packages</title>

      <para>The eXist-db package repository makes it easy to manage and deploy external packages
          (<code>.xar</code> archives) containing Java or XQuery libraries and even full eXist-db
        applications. See the <link xlink:href="repo.xml">Package Repository</link>
        documentation.</para>
    </sect2>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="xquery-caching">
    <title>XQuery Caching</title>

    <para>XQuery modules executed via the REST interface, the XQueryServlet or XQueryGenerator are
        <emphasis>automatically</emphasis> cached. The compiled expression will be added to an
      internal pool of prepared queries. The next time a query or module is loaded from the same
      location, the already compiled code is reused. The code will only be recompiled if eXist-db
      decides that the source was modified or when it wasn't used for a longer period of
      time.</para>
    <para>If a query is accessed by more than one thread concurrently, each new thread will create a
      new copy of the compiled query. The copies will be added to the query pool until it reaches a
      pre-defined limit.</para>
    <para>Modules are cached along with the main query that imported them.</para>
  </sect1>


  <!-- ================================================================== -->

  <sect1 xml:id="calling-java">
    <title>Calling Java Methods from XQuery</title>

    <para>eXist-db supports calls to arbitrary Java methods from within XQuery. The binding
      mechanism follows the short-cut technique introduced by <link xlink:href="http://saxon.sf.net"
        condition="_blank">Saxon</link>.</para>
    <para>The class of the external function is identified by the namespace URI of the function
      call. This namespace URI must start with the prefix <literal>java:</literal>, followed by the
      fully qualified class name of the class. For example, the following code snippet calls the
      static method <literal>sqrt</literal> (square-root) of class
      <literal>java.lang.Math</literal>:</para>
    <programlisting language="xquery" xlink:href="listings/listing-18.txt"/>

    <para>If the function name contains a hyphen, the letter following the hyphen is converted to
      upper-case and the hyphen is removed (to conform to the Java CamelCase naming convention). So
      for example, <code>to-string()</code> will call the Java method
      <code>toString()</code>.</para>
    <para>If more than one method in the class matches the given name and parameter count, eXist-db
      tries to select the method that best fits the passed parameter types at runtime. </para>
    <para>The result of the method call can be assigned to an XQuery variable. If possible, it will
      be mapped to the corresponding XML schema type. Otherwise, it's type is the eXist-db built-in
      type <literal>object</literal>.</para>
    <para>
      <emphasis>Java constructors</emphasis> are called using the function <literal>new</literal>.
      Again, a matching constructor is selected by looking at the parameter count and types. The
      returned value is a new Java object with the built-in type <literal>object</literal>.</para>
    <para>
      <emphasis>Instance methods</emphasis> are called by supplying a valid Java object as first
      parameter. The Java object has to be an instance of the given class. For example, the
      following snippet lists all files and directories in the current directory:</para>
    <programlisting language="xquery" xlink:href="listings/listing-19.txt"/>

    <note>
      <para>For security reasons, the Java binding is disabled by default. To enable it, the
        attribute <literal>enable-java-binding</literal> in the central configuration file has to be
        set to <literal>yes</literal>: </para>
      <programlisting>&lt;xquery enable-java-binding="yes"&gt;</programlisting>
      <para>Enabling the Java binding bears some risks: if you allow users to directly pass XQuery
        code to the database, for instance through the sandbox application, they can use Java
        methods to inspect your system or execute potentially destructive code on the server.</para>
    </note>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="modules">
    <title>Creating XQuery Modules</title>

    <para>eXist-db supports XQuery library modules, collections of function definitions and global
      variable declarations. eXist-db supports two types: <emphasis>External Modules</emphasis>,
      written in XQuery, and <emphasis>Internal Modules</emphasis>, implemented in Java. The
      standard XPath/XQuery functions and all standard eXist-db extension functions are implemented
      as internal modules. This section describes how to create XQuery modules using XQuery and
      Java.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xquery-modules">
      <title>Creating Modules in XQuery</title>

      <para>You can declare an XQuery file as a module and import it using the standard
          <literal>import module</literal> directive. The XQuery engine imports each module only
        once during compilation. The compiled module is made available through the static XQuery
        context.</para>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="java-modules">
      <title>Creating Modules in Java</title>

      <para>To register Java-based XQuery modules, eXist-db requires a namespace URI to identify it
        and the list of functions it supplies. For this, you need to pass a driver class to the
        XQuery engine. This class must implement the interface
          <literal>org.exist.xpath.InternalModule</literal>.</para>
      <note>
        <para>Besides the basic methods for creating a Java-based XQuery module described here,
          eXist-db provides a pluggable module interface that allows extension modules to be easily
          developed in Java. See <link xlink:href="extensions.xml">XQuery Extension Modules</link>
          for the full documentation on this eXist-db development best practice. Also, see the <link
            xlink:href="repo.xml">Package Repository</link> documentation for information on
          distributing and deploying XQuery and Java libraries for eXist-db.</para>
      </note>
      <para>The class <literal>org.exist.xpath.AbstractInternalModule</literal> already provides an
        implementation skeleton. The class constructor expects an array of function definitions for
        all functions to registered. A function definition (class <literal>FunctionDef</literal>)
        has two properties: the static signature of the function (as an instance of
          <literal>FunctionSignature</literal>) and the Java Class that implements the
        function.</para>
      <para>A function is a class extending <literal>org.exist.xquery.Function</literal> or
          <literal>org.exist.xquery.BasicFunction</literal>. Functions without special requirements
        (like overloading) should subclass BasicFunction. To illustrate this a simple function
        definition:</para>
      <programlisting language="java" xlink:href="listings/listing-21.txt"/>
      <itemizedlist>
        <listitem>
          <para>Note that every function class has to provide a function
              <emphasis>signature</emphasis>. This defines the <emphasis>QName</emphasis> by which
            the function is identified, a documentation string, the sequence types of all arguments
            and the sequence type of the returned value. </para>
          <para>In the example above, we accept a single argument named "text" of type
              <literal>xs:string</literal> and a cardinality of <literal>ZERO_OR_MORE</literal> with
            the description "The text to echo". In other words, we accept any sequence of strings
            containing zero or more items. The return value is of type <literal>xs:string</literal>
            and a cardinality of <literal>ZERO_OR_MORE</literal> with the description "the echoed
            text". </para>
          <para>A parameter description should be normal sentence starting with a capital letter.
            The return value description is always prefixed with "Returns ", so make sure the text
            matches. </para>
        </listitem>
        <listitem>
          <para>The subclass overwrites the <literal>eval</literal> method, which has two arguments:
            the first contains the values of all arguments passed to the function, the second passes
            the current context sequence (which might be <code>null</code>). </para>
          <para>Note that the argument values in the array <literal>args</literal> have already been
            checked to match the sequence types defined in the function signature. We therefore do
            not have to recheck the length of the array: if more or less than one argument were
            passed to the function, an exception would have been thrown before <code>eval</code>
            gets called.</para>
          <para>In XQuery, all values are passed as sequences. A sequence consists of one or more
            items, and every item is either an atomic value or a node. Furthermore, a single item is
            also a sequence. The function signature specifies that any sequence containing zero or
            more strings is acceptable for our method. We therefore have to check if the empty
            sequence has been passed. Here the function call returns immediately. Otherwise, we
            iterate through each item in the sequence, prefix <literal>echo:</literal> to its string
            value, and add it to the result sequence.</para>
        </listitem>

      </itemizedlist>

      <para>Now we want to add the function to a new module, so we have to provide a
          <emphasis>driver class</emphasis>. The driver class defines the namespace URI and default
        prefix for the module. Functions are registered by passing an array of
          <literal>FunctionDef</literal> to the constructor. The following is an example driver
        class definition:</para>
      <programlisting language="java" xlink:href="listings/listing-22.txt"/>

      <para>To use this in XQuery:</para>
      <programlisting language="xquery" xlink:href="listings/listing-23.txt"/>
      <para>The query engine recognizes the <literal>java:</literal> prefix in the location URI and
        treats the remaining part <literal>org.exist.examples.xquery.ExampleModule</literal> as a
        fully qualified class name leading to the driver class of the module.</para>

    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="collations">
    <title>Collations</title>

    <para>Collations are used to compare strings in a <emphasis>locale-sensitive</emphasis> fashion.
      XQuery allows to specify collations by means of a collation URI. For example, a collation can
      be specified in the <literal>order by</literal> clause of a XQuery FLWOR expression as well as
      in string-related functions. </para>

    <para>eXist-db recognizes the following standard collation URIs:</para>

    <variablelist>
      <varlistentry>
        <term>
          <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>
        </term>
        <listitem>
          <para>This URI selects the Unicode Codepoint Collation. This is default if no collation is
            specified. eXist implements this using standard Java comparison and string search
            functions.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>http://www.w3.org/2013/collation/UCA</code>
        </term>
        <listitem>
          <para>This URI selects the standard <link
              xlink:href="https://www.w3.org/TR/xpath-functions-31/#uca-collations"
              condition="_blank">Unicode Collation Algorithm (UCA)</link>, which accepts all
            standard parameters. eXist implements this using the ICU4J library.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive</code>
        </term>
        <listitem>
          <para>This URI selects the standard <link
              xlink:href="https://www.w3.org/TR/xpath-functions-31/#html-ascii-case-insensitive-collation"
              condition="_blank">HTML ASCII Case-Insensitive Collation</link>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>In addition, eXist-db supports an implementation-specific URI:</para>
    <variablelist>
      <varlistentry>
        <term>
          <code>http://exist-db.org/collation?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</code>
        </term>
        <listitem>

          <para>The <literal>lang</literal> parameter selects a locale, and should have the same
            form as in <literal>xml:lang</literal>. For example, "de" or "de-DE" to select the
            German locale.</para>
          <para>The optional <literal>strength</literal> parameter must be one of
              <code>primary</code>, <code>secondary</code>, <code>tertiary</code> or
              <code>identical</code>.</para>
          <para>The optional <code>decomposition</code> parameter (optional) has the value of
              <code>none</code>, <code>full</code> or <code>standard</code>.</para>
          <para>Instead of supplying the full URI, an abbreviated URI can be supplied instead:
              <code>?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</code>
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>The following example selects the German locale for sorting:</para>
    <programlisting language="xquery" xlink:href="listings/listing-27.txt"/>
    <para>It returns the following:</para>
    <programlisting>Bauer, Bäuerin, Buch, Bücher, das, daß, Jagen, Jäger</programlisting>
    <para>You can change the default collation in the XQuery prolog:</para>
    <programlisting language="xquery" xlink:href="listings/listing-29.txt"/>
    <para>This now returns <literal>true</literal> (the default collation would have returned
        <literal>false</literal>).</para>

    <para>Finally, you can also use Java class specified collators. They should be subclasses of
        <literal>java.text.RuleBasedCollator</literal>. For example:</para>
    <programlisting language="xquery" xlink:href="listings/listing-30.txt"/>
    <para>The <code>.jar</code> with the <code>.class</code> file(s) of the collator needs to be in
        <literal>${EXIST_HOME}/lib/user</literal>
    </para>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="serialization">
    <title>Serialization</title>

    <para>Serialization is the transformation of query results into a binary stream. eXist-db
      implements the <link xlink:href="http://www.w3.org/TR/xquery/" condition="_blank">"XSLT and
        XQuery Serialization 3.1"</link> specification. For example, the following serialization
      declaration instructs eXist-db to serialize query results as JSON and to supply a JSON
      media-type:</para>
    <programlisting language="xquery" xlink:href="listings/listing-10.txt"/>
    <para>As this example shows, serialization parameters can be set within the query itself.
      However, the interpretation of serialization parameters depends on the context in which the
      query is called. For instance, the JSON media-type declaration in the example above in only
      relevant in the context of an HTTP response header. Most output parameters are applicable only
      if the query is executed using the XQueryGenerator/XQueryServlet servlet or the REST
      server.</para>
    <para>Before serialization parameters were standardized in XQuery 3.0, eXist-db developed its
      own set of parameters, as described in below. These legacy parameters remain supported for
      backwards compatibility. For example, the eXist-db legacy approach to the JSON serialization
      declaration above is:</para>
    <programlisting language="xquery">declare option exist:serialize "method=json media-type=application/json";</programlisting>
    <para>Most of the legacy serialization parameters have an equivalent in the standard
      serialization parameters, but others are truly specific to eXist-db, and are thus accessible
      only using the legacy serialization approach.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="legacy-serialization">
      <title>eXist-db legacy serialization parameters</title>

      <para>Legacy serialization parameters can be set with a <literal>declare option</literal>
        statement in the query prolog. For instance:</para>
      <programlisting>declare option exist:serialize "method=xhtml media-type=application/xhtml+html";</programlisting>


      <para>The option's QName must be <literal>exist:serialize</literal>. The
          <literal>exist</literal> prefix is bound to the namespace
          <literal>http://exist.sourceforge.net/NS/exist</literal>. This is declared by default and
        need not be specified explicitly.</para>
      <para>Options are specified within the option's string literal, separated by
        whitespace.</para>


      <para>General options:</para>
      <variablelist spacing="compact">
        <varlistentry>
          <term>
            <literal>method= xml | xhtml | json | text</literal>
          </term>
          <listitem>
            <para>Determines the serialization method. Should be one of <code>xml</code>,
                <code>xhtml</code>, <code>json</code> or <code>text</code>. </para>
            <para>The <code>xhtml</code> method makes sure that XHTML elements with an empty content
              model are serialized in minimized form. For instance <tag>img</tag> will be output as
                <tag>img/</tag>. </para>
            <para>Unlike the <code>xml</code> method, the <code>xhtml</code> setting uses only the
              short form for the elements declared empty in the xhtml DTD. For example, the
                <tag>br</tag> tag is always returned as <code>&lt;br/&gt;</code>. </para>
            <para>The <code>text</code> method returns the contents of elements only. For instance,
                <code>&lt;A&gt;Content&lt;/A&gt;</code> is returned as <literal>Content</literal>.
              Attribute values, processing instructions and comments are ignored.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>jsonp= myFunctionName</literal>
          </term>
          <listitem>
            <para>Only relevant when the serialization method is set to <code>json</code>. Causes
              the JSON output to be wrapped in the named JSONP function. </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>media-type</literal>
          </term>
          <listitem>
            <para>The MIME content type of the output. It will be used to set the HTTP
                <code>Content-Type</code> header if the query is running in an HTTP context.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>encoding</literal>
          </term>
          <listitem>
            <para>Specifies the character encoding to be used for outputting the instance of the
              data model</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>doctype-public</literal> and <literal>doctype-system</literal>
          </term>
          <listitem>
            <para>a doctype declaration will be output if <code>doctype-public</code> and/or
                <code>doctype-system</code> are set. The corresponding identifier is taken from the
              value of the parameter.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>indent= yes | no</literal>
          </term>
          <listitem>
            <para>Indent the document to make it easier to read. Indenting adds whitespace
              characters to element nodes, restricted by the rules given in the XQuery serialization
              specification.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>omit-xml-declaration= yes | no</literal>
          </term>
          <listitem>
            <para>Output an XML declaration if the parameter is set to <code>no</code>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>expand-xincludes= yes | no</literal>
          </term>
          <listitem>
            <para>Must the serializer expand XInclude elements?</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>highlight-matches= both | elements | attributes | none</literal>
          </term>
          <listitem>
            <para>When querying text with the full text or n-gram extensions, the query engine
              tracks the exact position of all matches inside text content. The serializer can later
              use this information to mark those matches by wrapping them into an
                <tag>exist:match</tag> element.</para>
            <para>Setting <literal>highlight-matches=both</literal> will enable this feature for
              every kind of indexable node.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>process-xsl-pi= yes | no</literal>
          </term>
          <listitem>
            <para>If a document is serialized and it has an XSL processing instruction, eXist-db can
              try to load the referenced stylesheet and apply it to the document.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>add-exist-id= element | all | none</literal>
          </term>
          <listitem>
            <para>Shows the internal node ids of an element by adding an attribute
                <literal>exist:id="internal-node-id"</literal>. Setting add-exist-id to
                <code>element</code> will only show the node id of the top-level element,
                <code>all</code> will show the ids of all elements.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <literal>json-ignore-whitespace-text-nodes= yes | no</literal>
          </term>
          <listitem>
            <para>To discard white-space text nodes when serializing XML/XDM to JSON.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>For example, to disable XInclude expansion and indent the output, use the following
        syntax:</para>
      <programlisting>declare option exist:serialize "expand-xincludes=no indent=yes";</programlisting>


    </sect2>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="options">
    <title>Options</title>

    <para>eXist-db provides a number of useful options for controlling the query environment.</para>

    <sect2 xml:id="query-blocking">
      <title>Query Blocking</title>
      <para>To prevent the server from being blocked by a badly formulated query, eXist-db watches
        all query threads. A blocking query can be killed if it takes longer than a specified amount
        of time or consumes too many memory resources on the server. There are two options to
        control this behaviour:</para>
      <variablelist>
        <varlistentry>
          <term>
            <code>declare option exist:timeout "time-in-ms";</code>
          </term>
          <listitem>
            <para>Specifies the maximum amount of query processing time (in milliseconds) before it
              is cancelled by the XQuery engine.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>declare option exist:output-size-limit "size-hint";</code>
          </term>
          <listitem>
            <para>Defines a limit for the maximum size of a document fragment created within an
              XQuery. The limit is just an estimation, specified in terms of the accumulated number
              of nodes contained in all generated fragments. This can be used to prevent users from
              consuming too much memory if they are allowed to pass in their own XQueries.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="overriding-default-context">
      <title>Overriding the default XQuery Context</title>

      <para>eXist-db provides the following options to override the default XQuery context:</para>
      <variablelist>
        <varlistentry>
          <term>
            <code>declare option exist:implicit-timezone "duration";</code>
          </term>
          <listitem>
            <para>Specifies the <link xlink:href="http://www.w3.org/TR/xquery/#dt-timezone"
                condition="_blank">implicit timezone</link> for the XQuery context.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>declare option exist:current-dateTime "dateTime";</code>
          </term>
          <listitem>
            <para>Specifies the <link xlink:href="http://www.w3.org/TR/xquery/#GLdt-date-time"
                condition="_blank">current dateTime</link> for the XQuery context.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>declare option exist:optimize "enable=yes|no";</code>
          </term>
          <listitem>
            <para>Temporarily disables the query rewriting optimizer for the current query. Use for
              testing/debugging.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="pragmas">
    <title>Pragmas</title>

    <para>XQuery <link xlink:href="https://www.w3.org/TR/xquery/#id-extension-expressions"
        >pragmas</link> are a way to pass implementation-specific information to the query engine.
      Pragmas can be wrapped around an arbitrary XQuery expression.</para>

    <para>eXist-db recognizes the following pragmas:</para>

    <variablelist>
      <varlistentry>
        <term>
          <code>exist:timer</code>
        </term>
        <listitem>
          <para>Provides a simple way to measure the time executing a given expression. For
            example:</para>
          <programlisting>(# exist:timer #) { //some/path/expression }</programlisting>
          <para>This creates a timer for the expression enclosed in curly braces and prints timing
            information to the trace logger. Tracing needs to be enabled in
              <literal>log4j.xml</literal>:</para>
          <programlisting language="xml" xlink:href="listings/listing-36.xml"/>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:batch-transaction</code>
        </term>
        <listitem>
          <para>
            <emphasis>Currently for XQuery Update Extensions only.</emphasis> Provides a method for
            batching updates on the database into a single transaction, allowing a set of updates to
            be atomically guaranteed. </para>
          <para>For each affected document or collection, any configured Triggers will only be
            called once, the <literal>prepare()</literal> method will be fired before the first
            update to the configured resource and the <literal>finish()</literal> method fired after
            the last update to the configured resource.</para>
          <programlisting xlink:href="listings/listing-37.txt"/>
          <para>Uses a single Transaction and Trigger events for the expressions enclosed in curly
            braces.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:force-index-use</code>
        </term>
        <listitem>
          <para>
            <emphasis>For debugging purposes</emphasis>. Apply on an expression that uses indexes:
            comparisons, <literal>fn:matches()</literal>, etc. Will raise an error if, for any
            reason, the index cannot be used. This helps checking whether indexes are correctly
            defined or not.</para>
          <programlisting xlink:href="listings/listing-38.txt"/>
          <para>Raises an error if the general comparison doesn't use a range or a QName index
              (<code>XPDYxxxx</code>).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:no-index</code>
        </term>
        <listitem>
          <para>Prevents the query engine using any index. Useful if the searched value isn't very
            selective or if it is cheaper to traverse the previous step of a path expression than
            querying the index.</para>
          <programlisting xlink:href="listings/listing-39.txt"/>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:optimize</code>
        </term>
        <listitem>
          <para>This pragma is inserted automatically by the query rewriter to optimize an
            expression that implements the <literal>org.exist.xquery.Optimizable</literal>
            interface.</para>
          <programlisting>//((#exist:optimize#) { item[stock = 10] })</programlisting>
        </listitem>
      </varlistentry>
    </variablelist>

  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="community-specs">
    <title>Community Specifications</title>
    <para>In addition to providing robust support for the XPath and XQuery family of specifications,
      eXist-db has also implemented a number of <link xlink:href="http://expath.org/" condition="_blank">EXPath</link>
      and <link xlink:href="http://exquery.org/" condition="_blank">EXQuery</link> community specifications and modules
      that extend XPath and XQuery with cross-platform functions and capabilities. (Only those built
      into eXist are listed below; see eXist-db's Package Repository for others.)</para>

    <sect2 xml:id="http-client-module">
      <title>HTTP Client</title>
      <para>eXist-db implements the <link xlink:href="http://expath.org/spec/http-client"  condition="_blank">HTTP
          Client Module</link>, an EXPath specification for interacting with HTTP servers. This is
        in addition to eXist-db's native function libraries for performing HTTP <link
          xlink:href="/exist/apps/fundocs/view.html?uri=http://exist-db.org/xquery/request"
          >requests</link>.</para>
    </sect2>

    <sect2 xml:id="packaging-system">
      <title>Packaging System</title>
      <para>eXist-db implements the <link xlink:href="http://expath.org/spec/pkg">Packaging
          System</link>, an EXPath community specification for library and application packages. See
        the <link xlink:href="repo.xml">Package Repository</link> documentation.</para>
    </sect2>

    <sect2 xml:id="restxq">
      <title>RESTXQ</title>
      <para>eXist-db implements <link
        xlink:href="http://exquery.github.io/exquery/exquery-restxq-specification/restxq-1.0-specification.html" condition="_blank"
          >RESTXQ</link>, an EXQuery community effort to develop a clean approach for the deployment
        of RESTful services based on XQuery code annotations. This is in addition to eXist-db's
        native function libraries for performing HTTP <link
          xlink:href="/exist/apps/fundocs/view.html?uri=http://exist-db.org/xquery/request"
          >requests</link> and <link
          xlink:href="/exist/apps/fundocs/view.html?uri=http://exist-db.org/xquery/response"
          >responses</link>.</para>
    </sect2>

    <sect2 xml:id="zip-module">
      <title>ZIP</title>
      <para>eXist-db implements the <link xlink:href="http://expath.org/spec/zip">ZIP Module</link>,
        an EXPath community specification and module for performing compression. This is in addition
        to eXist-db's native function libraries for performing <link
          xlink:href="/exist/apps/fundocs/view.html?uri=http://exist-db.org/xquery/compression"
          >compression</link>.</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="legacy-features">
    <title>Legacy Features Maintained for Backward Compatibility</title>
    <para>The following legacy features are maintained for backwards compatibility reasons:</para>
    <itemizedlist>
      <listitem>
        <para>Collations: Some functions in eXist support collations, which are no longer in the
          specification.</para>
      </listitem>
      <listitem>
        <para>Map notation: During the drafting of XQuery 3.0, the specification changed slightly
          and so did the implementation in eXist-db. To keep backwards compatibility, eXist allows
          the older notation in map constructors: <code>key:=value</code> in addition to the new
          one, <code>key: value</code>.</para>
      </listitem>
      <listitem>
        <para>Serialization: Certain <link xlink:href="#legacy-serialization">Legacy Serialization
            Parameters</link>.</para>
      </listitem>
    </itemizedlist>
  </sect1>

</article>

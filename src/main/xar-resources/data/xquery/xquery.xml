<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng"
        schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml"
        schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink">
    <info>
        <title>XQuery in eXist-db</title>
        <date>2Q19</date>
        <keywordset>
            <keyword>xquery</keyword>
        </keywordset>
    </info>

    <!-- ================================================================== -->

    <para>eXist-db provides strong support for the W3C's family of recommendations for the XQuery
        language. eXist-db also supports a rich family of extension functions and capabilities,
        enabling XQuery developers to create powerful applications.</para>
    <para>This document is intended for advanced developers and explains eXist-db's implementation
        of XQuery. For readers who are new to XQuery or programming in general we recommend you
        start with the resources listed in <link xlink:href="learning-xquery">Learning XQuery with
        eXist-db</link> or <link xlink:href="development-starter">Getting Started with Web
        Application Development</link>.</para>

    <!-- ================================================================== -->

    <sect1 xml:id="current-status-of-xquery-support">
        <title>Current Status of XQuery Support</title>

        <para>eXist-db implements <link condition="_blank" xlink:href="https://www.w3.org/TR/xquery/"
            >XQuery 3.1: An XML Query Language</link> and <link condition="_blank"
            xlink:href="https://www.w3.org/TR/xpath-functions/">"XPath and XQuery Functions and
            Operators 3.1"</link>, with the exception of certain <link
            xlink:href="#unsupported-features">unsupported features and functions</link>. For
            complete documentation on functions in eXist-db, see <link condition="_blank"
            xlink:href="{${fundocs.pkg.abbrev}}">XQuery Function Documentation</link>.</para>
        <para>eXist-db's XQuery implementation has been tested against the official <link
            condition="_blank" xlink:href="https://dev.w3.org/2006/xquery-test-suite/">XML Query Test
            Suite (XQTS)</link>. An updated test suite runner to test conformance against the
            official <link condition="_blank" xlink:href="https://dev.w3.org/2011/QT3-test-suite/"
            >XQuery/XPath/XSLT 3.* Test Suite (QT3)</link> is being planned.</para>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="supported-optional-features">
            <title>Supported Optional Features</title>

            <para>In addition to the standard features, eXist-db provides extended support for <link
                xlink:href="#module-system"> <emphasis>modules</emphasis> </link>.</para>
            <para>It implements the <emphasis>full axis</emphasis> feature, providing support for
                the following <emphasis>optional axes</emphasis>: <literal>ancestor::</literal>,
                <literal>ancestor-or-self::</literal>, <literal>following::</literal>,
                <literal>following-sibling::</literal>, <literal>preceding::</literal> and
                <literal>preceding-sibling::</literal>. The only optional axis not supported is the
                <literal>namespace</literal> axis.</para>
        </sect2>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="unsupported-features">
            <title>Unsupported features</title>

            <para>eXist-db supports strong typing whenever the expected type of an expression,
                function argument, or function return value is explicitly specified or can be known
                otherwise. However, the following schema- and data type-related features are not
                supported:</para>
            <itemizedlist>
                <listitem>
                    <para> <link condition="_blank"
                        xlink:href="https://www.w3.org/TR/xquery/#id-schema-import-feature">schema
                        import</link> and <link condition="_blank"
                        xlink:href="https://www.w3.org/TR/xquery/#id-schema-validation-feature"
                        >schema validation features</link> (defined as <link condition="_blank"
                        xlink:href="https://www.w3.org/TR/xquery/#id-conform-optional-features"
                        >optional</link> in the XQuery specification). Instead, eXist-db provides a
                        <link condition="_blank"
                        xlink:href="{${fundocs.pkg.abbrev}}/view.html?uri=http://exist-db.org/xquery/validation"
                        >validation module</link> containing extension functions to perform XML
                        validation.</para>
                </listitem>
                <listitem>
                    <para>When storing XML documents, eXist-db does not store type information along
                        with the nodes. It therefore doesn't know the typed value of a node and has
                        to assume <literal>xs:untypedAtomic</literal> (as defined by the XQuery
                        specification).</para>
                </listitem>
                <listitem>
                    <para>eXist-db does not support specifying a data type in an element or
                        attribute test. The node test <literal>element(test-node)</literal> is
                        supported, but the type portion of the test <literal>element(test-node,
                        xs:integer)</literal> is ignored.</para>
                </listitem>
                <listitem>
                    <para>eXist supports all datatypes except <literal>xs:dateTimeStamp</literal>
                    </para>
                </listitem>
            </itemizedlist>

            <para>eXist-db supports standard XQuery FLWOR clause constructs except for the
                following:</para>
            <itemizedlist>
                <listitem>
                    <para>"tumbling window" and "sliding window" clauses</para>
                </listitem>
                <listitem>
                    <para>"count" clause</para>
                </listitem>
                <listitem>
                    <para>"allowing empty" clause</para>
                </listitem>
            </itemizedlist>

            <para>eXist-db supports all standard XQuery functions except for the following:</para>
            <itemizedlist>
                <listitem>
                    <para> <literal>array:put#3</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>array:sort#1, #2, #3</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:collation-key#1, #2</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:contains-token#2, #3</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:default-language#0</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:document-uri#0</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:element-with-id#1, #2</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:format-integer#2, #3</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:json-to-xml#1, #2</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:nilled#0</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:parse-ietf-date#1</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:path#0, #1</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:round#2</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:trace#1</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:transform#1</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:uri-collection#0, #1</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>fn:xml-to-json#1, #2</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>map:find#2</literal> </para>
                </listitem>
                <listitem>
                    <para> <literal>map:merge#2</literal> </para>
                </listitem>
            </itemizedlist>

            <para>eXist-db supports all standard serialization parameters except the
                following:</para>
            <itemizedlist>
                <listitem>
                    <para> <literal>item-separator</literal> </para>
                </listitem>
            </itemizedlist>
        </sect2>

    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="full-text">
        <title>Full Text Search</title>

        <para>eXist-db has an implementation-specific <link xlink:href="lucene">Full Text Search
            facility</link>, built on the <link condition="_blank"
            xlink:href="https://lucene.apache.org/">Apache Lucene</link> library (see the full
            documentation on <link xlink:href="indexing">indexing</link> in eXist-db). eXist-db
            does not currently support the official W3C <link condition="_blank"
            xlink:href="https://www.w3.org/TR/xpath-full-text/">"XQuery and XPath Full Text
            3.0"</link> specification.</para>

    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="update">
        <title>XQuery Update</title>

        <para>eXist-db has an implementation-specific <link xlink:href="update_ext">XQuery
            Update facility</link>, which predates the development of the official W3C XQuery Update
            facility. eXist-db does currently not support the official <link
            xlink:href="https://www.w3.org/TR/xquery-update/">"XQuery Update Facility 3.0"</link>
            specification. The main difference between the eXist-db implementation and the official
            specification is that the eXist-db implementation supports in-place updates. Switching
            to the W3C recommendation would break backwards compatibility.</para>

    </sect1>


    <!-- ================================================================== -->

    <sect1 xml:id="function-library">
        <title>Function Library</title>

        <para>A complete list of XQuery functions supported by eXist-db can be found in the <link
            condition="_blank" xlink:href="{${fundocs.pkg.abbrev}}">XQuery Function
            Documentation</link>. </para>
        <para>Each module's documentation is generated from a different sources, depending on
            whether the module is implemented in Java or XQuery. For modules implemented in Java,
            the documentation is taken directly from the signature provided by the class
            implementing the <literal>Function</literal> interface. For modules implemented in
            XQuery, the function descriptions are taken from <link xlink:href="xqdoc"
            >XQDoc-formatted comments and annotations</link>.</para>
    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="module-system">
        <title>The Module System</title>

        <para>eXist-db supports the creation of <link xlink:href="development-starter">web
            applications in XQuery</link>. This can result in complex XQuery scripts, consisting of
            several thousand lines of code. Packaging related functions in modules is therefore an
            important feature. eXist-db allows modules to be imported from a variety of
            sources:</para>
        <itemizedlist>
            <listitem>
                <para>an URI</para>
            </listitem>
            <listitem>
                <para>a collection in the database</para>
            </listitem>
            <listitem>
                <para>a jar file, usually a Java archive</para>
            </listitem>
            <listitem>
                <para>a Java class, if the module is implemented in Java itself</para>
            </listitem>
        </itemizedlist>

        <para>For example, a typical import statement in an XQuery will look like this:</para>
        <programlisting language="xquery" xlink:href="listings/listing-12.txt"/>
        <para>Provided the module namespace does not point to one of the preloaded standard modules
            (see below), the query engine will try to locate the module source by looking at the URI
            given after the <literal>at</literal> keyword. In the example above, the module was
            specified using a full URI and the query engine will attempt to load the module source
            from there. </para>
        <para>However, the module could also be stored in a database collection:</para>
        <programlisting language="xquery" xlink:href="listings/listing-13.txt"/>
        <para>The query engine recognizes the module is stored in the local database instance and
            tries to load it from there.</para>
        <para>If the XQuery module is part of a Java application, it is also an option to pack the
            module into a Java archive (<code>.jar</code> file) along with the Java classes. Then
            use the following <code>import</code> to load it:</para>
        <programlisting language="xquery" xlink:href="listings/listing-14.txt"/>
        <para>Finally, XQuery modules can also be implemented in Java (see <link
            xlink:href="#calling-java">below</link>).You can import them by specifying the class
            path of the Module class:</para>
        <programlisting language="xquery" xlink:href="listings/listing-15.txt"/>
        <para>The <literal>extensions/modules</literal> directory in the eXist-db distribution
            contains a number of useful modules. These can also serve as examples for implementing
            your own.</para>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="rel-uri">
            <title>Using Relative URIs</title>

            <para>If the location specified in an import statement is a relative URI, the query
                engine tries to load the module relatively to the current module load path. The
                module load path is determined as follows:</para>
            <orderedlist>
                <listitem>
                    <para>If the main XQuery was loaded from a database collection, the module load
                        path is the URI of that collection. For example if you access an XQuery via
                        the REST server:</para>
                    <programlisting>http://localhost:8080/exist/servlet/db/modules/test.xq</programlisting>
                    <para>Now all relative module paths will be resolved relative to the
                        <literal>/db/modules</literal> collection.</para>
                </listitem>
                <listitem>
                    <para>If the main XQuery was retrieved from the file system, the module load
                        path points to that directory. This applies to queries executed through the
                        XQueryServlet, XQueryGenerator or the Java admin client.</para>
                </listitem>

            </orderedlist>
        </sect2>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="preload">
            <title>Preloaded Modules</title>

            <para>Preloaded modules do not need to be explicitly imported or declared in the prolog
                of queries. The <tag>builtin-modules</tag> element in <literal>conf.xml</literal>
                lists the namespaces and the corresponding Java class that implements all modules to
                be preloaded:</para>
            <programlisting language="xml" xlink:href="listings/listing-17.xml"/>
        </sect2>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="expath-pkg">
            <title>EXPath Packages</title>

            <para>The eXist-db package repository makes it easy to manage and deploy external
                packages (<code>.xar</code> archives) containing Java or XQuery libraries and even
                full eXist-db applications. See the <link xlink:href="repo">Package
                Repository</link> documentation.</para>
        </sect2>

    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="xquery-caching">
        <title>XQuery Caching</title>

        <para>XQuery modules executed via the REST interface, the XQueryServlet or XQueryGenerator
            are <emphasis>automatically</emphasis> cached. The compiled expression will be added to
            an internal pool of prepared queries. The next time a query or module is loaded from the
            same location, the already compiled code is reused. The code will only be recompiled if
            eXist-db decides that the source was modified or when it wasn't used for a longer period
            of time.</para>
        <para>If a query is accessed by more than one thread concurrently, each new thread will
            create a new copy of the compiled query. The copies will be added to the query pool
            until it reaches a pre-defined limit.</para>
        <para>Modules are cached along with the main query that imported them.</para>
    </sect1>


    <!-- ================================================================== -->

    <sect1 xml:id="calling-java">
        <title>Calling Java Methods from XQuery</title>

        <para>eXist-db supports calls to arbitrary Java methods from within XQuery. The binding
            mechanism follows the short-cut technique introduced by <link condition="_blank"
            xlink:href="http://saxon.sourceforge.net/">Saxon</link>.</para>
        <para>The class of the external function is identified by the namespace URI of the function
            call. This namespace URI must start with the prefix <literal>java:</literal>, followed
            by the fully qualified class name of the class. For example, the following code snippet
            calls the static method <literal>sqrt</literal> (square-root) of class
            <literal>java.lang.Math</literal>:</para>
        <programlisting language="xquery" xlink:href="listings/listing-18.txt"/>

        <para>If the function name contains a hyphen, the letter following the hyphen is converted
            to upper-case and the hyphen is removed (to conform to the Java CamelCase naming
            convention). So for example, <code>to-string()</code> will call the Java method
            <code>toString()</code>.</para>
        <para>If more than one method in the class matches the given name and parameter count,
            eXist-db tries to select the method that best fits the passed parameter types at
            runtime. </para>
        <para>The result of the method call can be assigned to an XQuery variable. If possible, it
            will be mapped to the corresponding XML schema type. Otherwise, it's type is the
            eXist-db built-in type <literal>object</literal>.</para>
        <para> <emphasis>Java constructors</emphasis> are called using the function
            <literal>new</literal>. Again, a matching constructor is selected by looking at the
            parameter count and types. The returned value is a new Java object with the built-in
            type <literal>object</literal>.</para>
        <para> <emphasis>Instance methods</emphasis> are called by supplying a valid Java object as
            first parameter. The Java object has to be an instance of the given class. For example,
            the following snippet lists all files and directories in the current directory:</para>
        <programlisting language="xquery" xlink:href="listings/listing-19.txt"/>

        <note>
            <para>For security reasons, the Java binding is disabled by default. To enable it, the
                attribute <literal>enable-java-binding</literal> in the central configuration file
                has to be set to <literal>yes</literal>: </para>
            <programlisting>&lt;xquery enable-java-binding="yes"&gt;</programlisting>
            <para>Enabling the Java binding bears some risks: if you allow users to directly pass
                XQuery code to the database, for instance through the sandbox application, they can
                use Java methods to inspect your system or execute potentially destructive code on
                the server.</para>
        </note>
    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="modules">
        <title>Creating XQuery Modules</title>

        <para>eXist-db supports XQuery library modules, collections of function definitions and
            global variable declarations. eXist-db supports two types: <emphasis>External
            Modules</emphasis>, written in XQuery, and <emphasis>Internal Modules</emphasis>,
            implemented in Java. The standard XPath/XQuery functions and all standard eXist-db
            extension functions are implemented as internal modules. This section describes how to
            create XQuery modules using XQuery and Java.</para>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="xquery-modules">
            <title>Creating Modules in XQuery</title>

            <para>You can declare an XQuery file as a module and import it using the standard
                <literal>import module</literal> directive. The XQuery engine imports each module
                only once during compilation. The compiled module is made available through the
                static XQuery context.</para>
        </sect2>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="java-modules">
            <title>Creating Modules in Java</title>

            <para>To register Java-based XQuery modules, eXist-db requires a namespace URI to
                identify it and the list of functions it supplies. For this, you need to pass a
                driver class to the XQuery engine. This class must implement the interface
                <literal>org.exist.xpath.InternalModule</literal>.</para>
            <note>
                <para>Besides the basic methods for creating a Java-based XQuery module described
                    here, eXist-db provides a pluggable module interface that allows extension
                    modules to be easily developed in Java. See <link xlink:href="extensions"
                    >XQuery Extension Modules</link> for the full documentation on this eXist-db
                    development best practice. Also, see the <link xlink:href="repo">Package
                    Repository</link> documentation for information on distributing and deploying
                    XQuery and Java libraries for eXist-db.</para>
            </note>
            <para>The class <literal>org.exist.xpath.AbstractInternalModule</literal> already
                provides an implementation skeleton. The class constructor expects an array of
                function definitions for all functions to registered. A function definition (class
                <literal>FunctionDef</literal>) has two properties: the static signature of the
                function (as an instance of <literal>FunctionSignature</literal>) and the Java Class
                that implements the function.</para>
            <para>A function is a class extending <literal>org.exist.xquery.Function</literal> or
                <literal>org.exist.xquery.BasicFunction</literal>. Functions without special
                requirements (like overloading) should subclass BasicFunction. To illustrate this a
                simple function definition:</para>
            <programlisting language="java" xlink:href="listings/listing-21.txt"/>
            <itemizedlist>
                <listitem>
                    <para>Note that every function class has to provide a function
                        <emphasis>signature</emphasis>. This defines the <emphasis>QName</emphasis>
                        by which the function is identified, a documentation string, the sequence
                        types of all arguments and the sequence type of the returned value. </para>
                    <para>In the example above, we accept a single argument named "text" of type
                        <literal>xs:string</literal> and a cardinality of
                        <literal>ZERO_OR_MORE</literal> with the description "The text to echo". In
                        other words, we accept any sequence of strings containing zero or more
                        items. The return value is of type <literal>xs:string</literal> and a
                        cardinality of <literal>ZERO_OR_MORE</literal> with the description "the
                        echoed text". </para>
                    <para>A parameter description should be normal sentence starting with a capital
                        letter. The return value description is always prefixed with "Returns ", so
                        make sure the text matches. </para>
                </listitem>
                <listitem>
                    <para>The subclass overwrites the <literal>eval</literal> method, which has two
                        arguments: the first contains the values of all arguments passed to the
                        function, the second passes the current context sequence (which might be
                        <code>null</code>). </para>
                    <para>Note that the argument values in the array <literal>args</literal> have
                        already been checked to match the sequence types defined in the function
                        signature. We therefore do not have to recheck the length of the array: if
                        more or less than one argument were passed to the function, an exception
                        would have been thrown before <code>eval</code> gets called.</para>
                    <para>In XQuery, all values are passed as sequences. A sequence consists of one
                        or more items, and every item is either an atomic value or a node.
                        Furthermore, a single item is also a sequence. The function signature
                        specifies that any sequence containing zero or more strings is acceptable
                        for our method. We therefore have to check if the empty sequence has been
                        passed. Here the function call returns immediately. Otherwise, we iterate
                        through each item in the sequence, prefix <literal>echo:</literal> to its
                        string value, and add it to the result sequence.</para>
                </listitem>

            </itemizedlist>

            <para>Now we want to add the function to a new module, so we have to provide a
                <emphasis>driver class</emphasis>. The driver class defines the namespace URI and
                default prefix for the module. Functions are registered by passing an array of
                <literal>FunctionDef</literal> to the constructor. The following is an example
                driver class definition:</para>
            <programlisting language="java" xlink:href="listings/listing-22.txt"/>

            <para>To use this in XQuery:</para>
            <programlisting language="xquery" xlink:href="listings/listing-23.txt"/>
            <para>The query engine recognizes the <literal>java:</literal> prefix in the location
                URI and treats the remaining part
                <literal>org.exist.examples.xquery.ExampleModule</literal> as a fully qualified
                class name leading to the driver class of the module.</para>

        </sect2>
    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="collations">
        <title>Collations</title>

        <para>Collations are used to compare strings in a <emphasis>locale-sensitive</emphasis>
            fashion. XQuery allows to specify collations by means of a collation URI. For example, a
            collation can be specified in the <literal>order by</literal> clause of a XQuery FLWOR
            expression as well as in string-related functions. </para>

        <para>eXist-db recognizes the following standard collation URIs:</para>

        <variablelist>
            <varlistentry>
                <term> <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code> </term>
                <listitem>
                    <para>This URI selects the Unicode Codepoint Collation. This is default if no
                        collation is specified. eXist implements this using standard Java comparison
                        and string search functions.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term> <code>http://www.w3.org/2013/collation/UCA</code> </term>
                <listitem>
                    <para>This URI selects the standard <link condition="_blank"
                        xlink:href="https://www.w3.org/TR/xpath-functions-31/#uca-collations"
                        >Unicode Collation Algorithm (UCA)</link>, which accepts all standard
                        parameters. eXist implements this using the ICU4J library.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <code>http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive</code> </term>
                <listitem>
                    <para>This URI selects the standard <link condition="_blank"
                        xlink:href="https://www.w3.org/TR/xpath-functions-31/#html-ascii-case-insensitive-collation"
                        >HTML ASCII Case-Insensitive Collation</link>.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term> <code>http://www.w3.org/2010/09/qt-fots-catalog/collation/caseblind</code> </term>
                <listitem>
                    <para>This URI selects the Collation used by the XQTS (XQuery Test Suite) 3.1.
                        It is not recommended to use this for general purposes.</para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para>In addition, eXist-db supports a legcacy implementation-specific collation. This
            should no longer be used, instead the Unicode Collation Algorithm (UCA) or Unicode
            Codepoint Collation should be used. For reference the legacy collation URI is:</para>
        <variablelist>
            <varlistentry>
                <term>
                    <code>http://exist-db.org/collation?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</code> </term>
                <listitem>

                    <para>The <literal>lang</literal> parameter selects a locale, and should have
                        the same form as in <literal>xml:lang</literal>. For example, "de" or
                        "de-DE" to select the German locale.</para>
                    <para>The optional <literal>strength</literal> parameter must be one of
                        <code>primary</code>, <code>secondary</code>, <code>tertiary</code> or
                        <code>identical</code>.</para>
                    <para>The optional <code>decomposition</code> parameter (optional) has the value
                        of <code>none</code>, <code>full</code> or <code>standard</code>.</para>
                    <para>Instead of supplying the full URI, an abbreviated URI can be supplied
                        instead: <code>?lang=xxx&amp;strength=xxx&amp;decomposition=xxx</code>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para>The following example selects the German locale for sorting:</para>
        <programlisting language="xquery" xlink:href="listings/listing-27.txt"/>
        <para>It returns the following:</para>
        <programlisting>Bauer, Bäuerin, Buch, Bücher, das, daß, Jagen, Jäger</programlisting>
        <para>You can change the default collation in the XQuery prolog:</para>
        <programlisting language="xquery" xlink:href="listings/listing-29.txt"/>
        <para>This now returns <literal>true</literal> (the default collation would have returned
            <literal>false</literal>).</para>

        <para>Finally, you can also use Java class specified collators. They should be subclasses of
            <literal>java.text.RuleBasedCollator</literal>. For example:</para>
        <programlisting language="xquery" xlink:href="listings/listing-30.txt"/>
        <para>The <code>.jar</code> with the <code>.class</code> file(s) of the collator needs to be
            placed in <literal>${EXIST_HOME}/lib</literal> and added to the appropriate classpath
            config file in <literal>${EXIST_HOME}/etc</literal>, for standard server deployments this is <literal>${EXIST_HOME}/etc/startup.xml</literal>.</para>

    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="serialization">
        <title>Serialization</title>

        <para>Serialization is the transformation of query results into a binary stream. eXist-db
            implements the <link condition="_blank" xlink:href="https://www.w3.org/TR/xquery/">"XSLT
            and XQuery Serialization 3.1"</link> specification. For example, the following
            serialization declaration instructs eXist-db to serialize query results as JSON and to
            supply a JSON media-type:</para>
        <programlisting language="xquery" xlink:href="listings/listing-10.txt"/>
        <para>As this example shows, serialization parameters can be set within the query itself.
            However, the interpretation of serialization parameters depends on the context in which
            the query is called. For instance, the JSON media-type declaration in the example above
            in only relevant in the context of an HTTP response header. Most output parameters are
            applicable only if the query is executed using the XQueryGenerator/XQueryServlet servlet
            or the REST server.</para>
        <para>Before serialization parameters were standardized in XQuery 3.0, eXist-db developed
            its own set of parameters, as described in below. These legacy parameters remain
            supported for backwards compatibility. For example, the eXist-db legacy approach to the
            JSON serialization declaration above is:</para>
        <programlisting language="xquery">declare option exist:serialize "method=json media-type=application/json";</programlisting>
        <para>Most of the legacy serialization parameters have an equivalent in the standard
            serialization parameters, but others are truly specific to eXist-db, and are thus
            accessible only using the legacy serialization approach.</para>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="legacy-serialization">
            <title>eXist-db legacy serialization parameters</title>

            <para>Legacy serialization parameters can be set with a <literal>declare
                option</literal> statement in the query prolog. For instance:</para>
            <programlisting>declare option exist:serialize "method=xhtml media-type=application/xhtml+html";</programlisting>


            <para>The option's QName must be <literal>exist:serialize</literal>. The
                <literal>exist</literal> prefix is bound to the namespace
                <literal>http://exist.sourceforge.net/NS/exist</literal>. This is declared by
                default and need not be specified explicitly.</para>
            <para>Options are specified within the option's string literal, separated by
                whitespace.</para>


            <para>General options:</para>
            <variablelist spacing="compact">
                <varlistentry>
                    <term> <literal>method= xml | xhtml | json | text</literal> </term>
                    <listitem>
                        <para>Determines the serialization method. Should be one of
                            <code>xml</code>, <code>xhtml</code>, <code>json</code> or
                            <code>text</code>. </para>
                        <para>The <code>xhtml</code> method makes sure that XHTML elements with an
                            empty content model are serialized in minimized form. For instance
                            <tag>img</tag> will be output as <tag>img/</tag>. </para>
                        <para>Unlike the <code>xml</code> method, the <code>xhtml</code> setting
                            uses only the short form for the elements declared empty in the xhtml
                            DTD. For example, the <tag>br</tag> tag is always returned as
                            <code>&lt;br/&gt;</code>. </para>
                        <para>The <code>text</code> method returns the contents of elements only.
                            For instance, <code>&lt;A&gt;Content&lt;/A&gt;</code> is returned as
                            <literal>Content</literal>. Attribute values, processing instructions
                            and comments are ignored.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>jsonp= myFunctionName</literal> </term>
                    <listitem>
                        <para>Only relevant when the serialization method is set to
                            <code>json</code>. Causes the JSON output to be wrapped in the named
                            JSONP function. </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>media-type</literal> </term>
                    <listitem>
                        <para>The MIME content type of the output. It will be used to set the HTTP
                            <code>Content-Type</code> header if the query is running in an HTTP
                            context.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>encoding</literal> </term>
                    <listitem>
                        <para>Specifies the character encoding to be used for outputting the
                            instance of the data model</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>doctype-public</literal> and <literal>doctype-system</literal> </term>
                    <listitem>
                        <para>a doctype declaration will be output if <code>doctype-public</code>
                            and/or <code>doctype-system</code> are set. The corresponding identifier
                            is taken from the value of the parameter.</para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term> <literal>indent= yes | no</literal> </term>
                    <listitem>
                        <para>Indent the document to make it easier to read. Indenting adds
                            whitespace characters to element nodes, restricted by the rules given in
                            the XQuery serialization specification.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>omit-xml-declaration= yes | no</literal> </term>
                    <listitem>
                        <para>Output an XML declaration if the parameter is set to <code>no</code>
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term> <literal>expand-xincludes= yes | no</literal> </term>
                    <listitem>
                        <para>Must the serializer expand XInclude elements?</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>highlight-matches= both | elements | attributes | none</literal> </term>
                    <listitem>
                        <para>When querying text with the full text or n-gram extensions, the query
                            engine tracks the exact position of all matches inside text content. The
                            serializer can later use this information to mark those matches by
                            wrapping them into an <tag>exist:match</tag> element.</para>
                        <para>Setting <literal>highlight-matches=both</literal> will enable this
                            feature for every kind of indexable node.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>process-xsl-pi= yes | no</literal> </term>
                    <listitem>
                        <para>If a document is serialized and it has an XSL processing instruction,
                            eXist-db can try to load the referenced stylesheet and apply it to the
                            document.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>add-exist-id= element | all | none</literal> </term>
                    <listitem>
                        <para>Shows the internal node ids of an element by adding an attribute
                            <literal>exist:id="internal-node-id"</literal>. Setting add-exist-id to
                            <code>element</code> will only show the node id of the top-level
                            element, <code>all</code> will show the ids of all elements.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <literal>json-ignore-whitespace-text-nodes= yes | no</literal> </term>
                    <listitem>
                        <para>To discard white-space text nodes when serializing XML/XDM to
                            JSON.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>For example, to disable XInclude expansion and indent the output, use the
                following syntax:</para>
            <programlisting>declare option exist:serialize "expand-xincludes=no indent=yes";</programlisting>


        </sect2>

    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="options">
        <title>Options</title>

        <para>eXist-db provides a number of useful options for controlling the query
            environment.</para>

        <sect2 xml:id="query-blocking">
            <title>Query Blocking</title>
            <para>To prevent the server from being blocked by a badly formulated query, eXist-db
                watches all query threads. A blocking query can be killed if it takes longer than a
                specified amount of time or consumes too many memory resources on the server. There
                are two options to control this behaviour:</para>
            <variablelist>
                <varlistentry>
                    <term> <code>declare option exist:timeout "time-in-ms";</code> </term>
                    <listitem>
                        <para>Specifies the maximum amount of query processing time (in
                            milliseconds) before it is cancelled by the XQuery engine.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <code>declare option exist:output-size-limit "size-hint";</code> </term>
                    <listitem>
                        <para>Defines a limit for the maximum size of a document fragment created
                            within an XQuery. The limit is just an estimation, specified in terms of
                            the accumulated number of nodes contained in all generated fragments.
                            This can be used to prevent users from consuming too much memory if they
                            are allowed to pass in their own XQueries.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </sect2>

        <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

        <sect2 xml:id="overriding-default-context">
            <title>Overriding the default XQuery Context</title>

            <para>eXist-db provides the following options to override the default XQuery
                context:</para>
            <variablelist>
                <varlistentry>
                    <term> <code>declare option exist:implicit-timezone "duration";</code> </term>
                    <listitem>
                        <para>Specifies the <link condition="_blank"
                            xlink:href="https://www.w3.org/TR/xquery/#dt-timezone">implicit
                            timezone</link> for the XQuery context.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <code>declare option exist:current-dateTime "dateTime";</code> </term>
                    <listitem>
                        <para>Specifies the <link condition="_blank"
                            xlink:href="https://www.w3.org/TR/xquery/#GLdt-date-time">current
                            dateTime</link> for the XQuery context.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> <code>declare option exist:optimize "enable=yes|no";</code> </term>
                    <listitem>
                        <para>Temporarily disables the query rewriting optimizer for the current
                            query. Use for testing/debugging.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </sect2>
    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="pragmas">
        <title>Pragmas</title>

        <para>XQuery <link xlink:href="https://www.w3.org/TR/xquery/#id-extension-expressions"
            >pragmas</link> are a way to pass implementation-specific information to the query
            engine. Pragmas can be wrapped around an arbitrary XQuery expression.</para>

        <para>eXist-db recognizes the following pragmas:</para>

        <variablelist>
            <varlistentry>
                <term> <code>exist:timer</code> </term>
                <listitem>
                    <para>Provides a simple way to measure the time executing a given expression.
                        For example:</para>
                    <programlisting>(# exist:timer #) { //some/path/expression }</programlisting>
                    <para>This creates a timer for the expression enclosed in curly braces and
                        prints timing information to the trace logger. Tracing needs to be enabled
                        in <literal>log4j.xml</literal>:</para>
                    <programlisting language="xml" xlink:href="listings/listing-36.xml"/>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term> <code>exist:batch-transaction</code> </term>
                <listitem>
                    <para> <emphasis>Currently for XQuery Update Extensions only.</emphasis>
                        Provides a method for batching updates on the database into a single
                        transaction, allowing a set of updates to be atomically guaranteed. </para>
                    <para>For each affected document or collection, any configured Triggers will
                        only be called once, the <literal>prepare()</literal> method will be fired
                        before the first update to the configured resource and the
                        <literal>finish()</literal> method fired after the last update to the
                        configured resource.</para>
                    <programlisting xlink:href="listings/listing-37.txt"/>
                    <para>Uses a single Transaction and Trigger events for the expressions enclosed
                        in curly braces.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term> <code>exist:force-index-use</code> </term>
                <listitem>
                    <para> <emphasis>For debugging purposes</emphasis>. Apply on an expression that
                        uses indexes: comparisons, <literal>fn:matches()</literal>, etc. Will raise
                        an error if, for any reason, the index cannot be used. This helps checking
                        whether indexes are correctly defined or not.</para>
                    <programlisting xlink:href="listings/listing-38.txt"/>
                    <para>Raises an error if the general comparison doesn't use a range or a QName
                        index (<code>XPDYxxxx</code>).</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term> <code>exist:no-index</code> </term>
                <listitem>
                    <para>Prevents the query engine using any index. Useful if the searched value
                        isn't very selective or if it is cheaper to traverse the previous step of a
                        path expression than querying the index.</para>
                    <programlisting xlink:href="listings/listing-39.txt"/>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term> <code>exist:optimize</code> </term>
                <listitem>
                    <para>This pragma is inserted automatically by the query rewriter to optimize an
                        expression that implements the
                        <literal>org.exist.xquery.Optimizable</literal> interface.</para>
                    <programlisting>//((#exist:optimize#) { item[stock = 10] })</programlisting>
                </listitem>
            </varlistentry>
        </variablelist>

    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="community-specs">
        <title>Community Specifications</title>
        <para>In addition to providing robust support for the XPath and XQuery family of
            specifications, eXist-db has also implemented a number of <link condition="_blank"
            xlink:href="http://expath.org/">EXPath</link> and <link condition="_blank"
            xlink:href="http://exquery.org/">EXQuery</link> community specifications and modules
            that extend XPath and XQuery with cross-platform functions and capabilities. (Only those
            built into eXist are listed below; see eXist-db's Package Repository for others.)</para>

        <sect2 xml:id="http-client-module">
          <title>HTTP Client</title>
          <para>eXist-db implements the <link condition="_blank" xlink:href="http://expath.org/spec/http-client">HTTP Client Module</link>, an EXPath specification for interacting with HTTP servers.</para>
        </sect2>
        <sect2 xml:id="packaging-system">
            <title>Packaging System</title>
            <para>eXist-db implements the <link xlink:href="http://expath.org/spec/pkg">Packaging
                System</link>, an EXPath community specification for library and application
                packages. See the <link xlink:href="repo">Package Repository</link>
                documentation.</para>
        </sect2>

        <sect2 xml:id="restxq">
            <title>RESTXQ</title>
            <para>eXist-db implements <link condition="_blank"
                xlink:href="http://exquery.github.io/exquery/exquery-restxq-specification/restxq-1.0-specification.html"
                >RESTXQ</link>, an EXQuery community effort to develop a clean approach for the
                deployment of RESTful services based on XQuery code annotations. This is in addition
                to eXist-db's native function libraries for performing HTTP <link
                xlink:href="{${fundocs.pkg.abbrev}}/view.html?uri=http://exist-db.org/xquery/request"
                >requests</link> and <link
                xlink:href="{${fundocs.pkg.abbrev}}/view.html?uri=http://exist-db.org/xquery/response"
                >responses</link>.</para>
        </sect2>

        <sect2 xml:id="zip-module">
            <title>ZIP</title>
            <para>eXist-db implements the <link xlink:href="http://expath.org/spec/zip">ZIP
                Module</link>, an EXPath community specification and module for performing
                compression. This is in addition to eXist-db's native function libraries for
                performing <link
                xlink:href="{${fundocs.pkg.abbrev}}/view.html?uri=http://exist-db.org/xquery/compression"
                >compression</link>.</para>
        </sect2>
    </sect1>

    <!-- ================================================================== -->

    <sect1 xml:id="legacy-features">
        <title>Legacy Features Maintained for Backward Compatibility</title>
        <para>The following legacy features are maintained for backwards compatibility
            reasons:</para>
        <itemizedlist>
            <listitem>
                <para>Collations: Some functions in eXist support collations, which are no longer in
                    the specification.</para>
            </listitem>
            <listitem>
                <para>Map notation: During the drafting of XQuery 3.0, the specification changed
                    slightly and so did the implementation in eXist-db. To keep backwards
                    compatibility, eXist allows the older notation in map constructors:
                    <code>key:=value</code> in addition to the new one, <code>key:
                    value</code>.</para>
            </listitem>
            <listitem>
                <para>Serialization: Certain <link xlink:href="#legacy-serialization">Legacy
                    Serialization Parameters</link>.</para>
            </listitem>
        </itemizedlist>
    </sect1>

</article>
